---
title: "ERCC normalization"
date: 2015-06-15
---

**Last updated:** `r Sys.Date()`

**Code version:** `r system("git log -1 --format='%H'", intern = TRUE)`

```{r chunk-options, include=FALSE}
source("chunk-options.R")
```

Testing different approaches to normalize the data.

For the bulk samples, the data used is the TMM-normalized log2 reads per million.
The only exception to this is with RUVg because it expects count data.

For the single cell samples, the data is the log2 molecules per million after correcting for the collision probability.
The only exception to this is with RUVg because it expects count data.
Also, batch 2 of individual 19098 is removed because its ERCC data 

Linear shift normalization
RUVseq normalization
Empirical quantile normalization
Loess normalization


## Setup

```{r packages, message=FALSE}
library("edgeR")
library("ggplot2")
theme_set(theme_bw(base_size = 16))
library("RUVSeq")
library("preprocessCore")
library("affy")
source("functions.R")
```

Input annotation.

```{r input-annotation}
anno <- read.table("../data/annotation.txt", header = TRUE,
                   stringsAsFactors = FALSE)
head(anno)
```

Input read counts.

```{r input-read-counts}
reads <- read.table("../data/reads.txt", header = TRUE,
                    stringsAsFactors = FALSE)
```

Input molecule counts.

```{r input-molecule-counts}
molecules <- read.table("../data/molecules.txt", header = TRUE,
                    stringsAsFactors = FALSE)
```

Input ERCC concentration information.

```{r input-ercc}
ercc <- read.table("../data/ercc-info.txt", header = TRUE, sep = "\t",
                   stringsAsFactors = FALSE)
colnames(ercc) <- c("num", "id", "subgroup", "conc_mix1", "conc_mix2",
                    "expected_fc", "log2_mix1_mix2")
head(ercc)
stopifnot(nrow(ercc) == 92)
```

Input list of quality single cells.

```{r input-quality-single-cells}
quality_single_cells <- scan("../data/quality-single-cells.txt",
                             what = "character")
```

## Prepare single cell molecule data

Keep only the single cells that passed the [QC filters](qc-cell-ipsc.html).
This also removes the bulk samples.

```{r qc-filter}
molecules_single <- molecules[, colnames(molecules) %in% quality_single_cells]
anno_single <- anno[anno$sample_id %in% quality_single_cells, ]
stopifnot(ncol(molecules_single) == nrow(anno_single),
          colnames(molecules_single) == anno_single$sample_id)
```

Also remove batch 2 of individual 19098.

```{r remove-19098-batch-2-single}
molecules_single <- molecules_single[, !(anno_single$individual == 19098 & anno_single$batch == 2)]
anno_single <- anno_single[!(anno_single$individual == 19098 & anno_single$batch == 2), ]
stopifnot(ncol(molecules_single) == nrow(anno_single))
```

Remove genes with zero read counts in the single cells.

```{r remove-non-expressed-genes}
expressed_single <- rowSums(molecules_single) > 0
molecules_single <- molecules_single[expressed_single, ]
dim(molecules_single)
```

How many genes have greater than or equal to 1,024 molecules in at least one of the cells?

```{r over-expressed}
overexpressed_genes <- rownames(molecules_single)[apply(molecules_single, 1,
                                                        function(x) any(x >= 1024))]
```

`r length(overexpressed_genes)` have greater than or equal to 1,024 molecules.
Remove them.

```{r remove-over-expressed}
molecules_single <- molecules_single[!(rownames(molecules_single) %in% overexpressed_genes), ]
```

Correct for the collision probability.
See [Grun et al. 2014][Grun2014] for details.

```{r collision-probability}
molecules_single_collision <- -1024 * log(1 - molecules_single / 1024)
```

[Grun2014]: http://www.nature.com/nmeth/journal/v11/n6/full/nmeth.2930.html#methods

Standardize the molecule counts to account for differences in sequencing depth.
This is necessary because the [sequencing depth affects the total molecule counts](compare-reads-v-molecules.html#effect-of-sequencing-depth-on-molecule-count).

```{r calc-cpm-single}
molecules_single_cpm <- cpm(molecules_single_collision, log = TRUE)
```

## Prepare bulk cell read data

Select bulk samples.

```{r select-bulk-reads}
reads_bulk <- reads[, anno$well == "bulk"]
anno_bulk <- anno[anno$well == "bulk", ]
stopifnot(ncol(reads_bulk) == nrow(anno_bulk),
          colnames(reads_bulk) == anno_bulk$sample_id)
```

Remove genes with zero reads in the bulk cells.

```{r remove-non-expressed-genes-bulk-reads}
expressed_bulk <- rowSums(reads_bulk) > 0
reads_bulk <- reads_bulk[expressed_bulk, ]
dim(reads_bulk)
```

Calculate TMM-normalized read counts per million.

```{r calc-cpm-bulk-reads}
norm_factors_bulk <- calcNormFactors(reads_bulk, method = "TMM")
reads_bulk_cpm <- cpm(reads_bulk, log = TRUE,
                          lib.size = colSums(reads_bulk) * norm_factors_bulk)
```

## Prepare ERCC data

Obtain the row indices for the ERCC spike-ins and the genes.

```{r ercc-gene-index}
ercc_rows_single <- grep("ERCC", rownames(molecules_single))
gene_rows_single <- grep("ERCC", rownames(molecules_single), invert = TRUE)
ercc_rows_bulk <- grep("ERCC", rownames(reads_bulk))
gene_rows_bulk <- grep("ERCC", rownames(reads_bulk), invert = TRUE)
```

The single molecule data has `r length(ercc_rows_single)` ERCC spike-ins and `r length(gene_rows_single)` genes.

The bulk read data has `r length(ercc_rows_bulk)` ERCC spike-ins and `r length(gene_rows_bulk)` genes.

Sort ERCC data file by the spike-in ID.

```{r sort-ercc}
ercc <- ercc[order(ercc$id), ]
# Also remove spike-ins with no counts
ercc_single <- ercc[ercc$id %in% rownames(molecules_single), ]
stopifnot(rownames(molecules_single[ercc_rows_single, ]) == ercc_single$id)
ercc_bulk <- ercc[ercc$id %in% rownames(reads_bulk), ]
stopifnot(rownames(reads_bulk[ercc_rows_bulk, ]) == ercc_bulk$id)
```

## Linear shift normalization

Perform the normalization separately for bulk and single cells.
Use the counts per million.

Adjust each individual sample based on its ERCC counts.

```{r bulk-adjust}
bulk_norm <- reads_bulk_cpm
bulk_norm[, ] <- NA
for (i in 1:ncol(bulk_norm)) {
  bulk_fit <- lm(reads_bulk_cpm[ercc_rows_bulk, i] ~ log2(ercc_bulk$conc_mix1))
  # Y = mX + b -> X = (Y + b) / m
  bulk_norm[, i] <- (reads_bulk_cpm[, i] + bulk_fit$coefficients[1]) /
                     bulk_fit$coefficients[2]
}
stopifnot(!is.na(bulk_norm))
```

```{r single-adjust}
single_norm <- molecules_single_cpm
single_norm[, ] <- NA
for (i in 1:ncol(single_norm)) {
  single_fit <- lm(molecules_single_cpm[ercc_rows_single, i] ~ log2(ercc_single$conc_mix1))
  # Y = mX + b -> X = (Y + b) / m
  single_norm[, i] <- (molecules_single_cpm[, i] + single_fit$coefficients[1]) /
                       single_fit$coefficients[2]
}
stopifnot(!is.na(single_norm))
```

## RUVseq normalization

Use RUVg from [Risso et al., 2014][Risso2014].
It uses the ERCC spike-ins as negative control genes to correct for unwanted variation.
It uses counts as input and output.
It requires one parameter to be chosen:
`k` is the "number of factors of unwanted variation to be estimated from the data".

[Risso2014]: http://www.nature.com/nbt/journal/v32/n9/full/nbt.2931.html

For k = 1:

```{r bulk-ruv-k1}
bulk_ruv_object_k1 <- RUVg(x = as.matrix(reads_bulk), cIdx = ercc_rows_bulk, k = 1)
bulk_ruv_k1 <- bulk_ruv_object_k1$normalizedCounts
bulk_ruv_cpm_k1 <- cpm(bulk_ruv_k1, log = TRUE,
                       lib.size = calcNormFactors(bulk_ruv_k1) * colSums(bulk_ruv_k1))
```

```{r single-ruv-k1}
single_ruv_object_k1 <- RUVg(x = as.matrix(molecules_single), cIdx = ercc_rows_single, k = 1)
single_ruv_k1 <- single_ruv_object_k1$normalizedCounts
single_ruv_cpm_k1 <- cpm(single_ruv_k1, log = TRUE,
                      lib.size = calcNormFactors(single_ruv_k1) * colSums(single_ruv_k1))
```

For k = 5:

```{r bulk-ruv-k5}
bulk_ruv_object_k5 <- RUVg(x = as.matrix(reads_bulk), cIdx = ercc_rows_bulk, k = 5)
bulk_ruv_k5 <- bulk_ruv_object_k5$normalizedCounts
bulk_ruv_cpm_k5 <- cpm(bulk_ruv_k5, log = TRUE,
                       lib.size = calcNormFactors(bulk_ruv_k5) * colSums(bulk_ruv_k5))
```

```{r single-ruv-k5}
single_ruv_object_k5 <- RUVg(x = as.matrix(molecules_single), cIdx = ercc_rows_single, k = 5)
single_ruv_k5 <- single_ruv_object_k5$normalizedCounts
single_ruv_cpm_k5 <- cpm(single_ruv_k5, log = TRUE,
                      lib.size = calcNormFactors(single_ruv_k5) * colSums(single_ruv_k5))
```

For k = 10:

```{r bulk-ruv-k10}
bulk_ruv_object_k10 <- RUVg(x = as.matrix(reads_bulk), cIdx = ercc_rows_bulk, k = 10)
bulk_ruv_k10 <- bulk_ruv_object_k10$normalizedCounts
bulk_ruv_cpm_k10 <- cpm(bulk_ruv_k10, log = TRUE,
                       lib.size = calcNormFactors(bulk_ruv_k10) * colSums(bulk_ruv_k10))
```

```{r single-ruv-k10}
single_ruv_object_k10 <- RUVg(x = as.matrix(molecules_single), cIdx = ercc_rows_single, k = 10)
single_ruv_k10 <- single_ruv_object_k10$normalizedCounts
single_ruv_cpm_k10 <- cpm(single_ruv_k10, log = TRUE,
                      lib.size = calcNormFactors(single_ruv_k10) * colSums(single_ruv_k10))
```

k = 10 removes all gene expression variation from the bulk data:

```{r}
sum(apply(bulk_ruv_cpm_k10[gene_rows_bulk, ], 1, var) == 0)
nrow(bulk_ruv_cpm_k10[gene_rows_bulk, ])
```

For k = 30 for single cells only:

```{r single-ruv-k30}
single_ruv_object_k30 <- RUVg(x = as.matrix(molecules_single), cIdx = ercc_rows_single, k = 30)
single_ruv_k30 <- single_ruv_object_k30$normalizedCounts
single_ruv_cpm_k30 <- cpm(single_ruv_k30, log = TRUE,
                      lib.size = calcNormFactors(single_ruv_k30) * colSums(single_ruv_k30))
```

## Empirical quantile normalization

Instead of using the ERCC specifically as a guide, simply perform an empirical quantile normalization (including both the genes and ERCC controls).

```{r bulk-quant}
# from package preprocessCore
bulk_quant <- normalize.quantiles(as.matrix(reads_bulk_cpm))
```

```{r single-quant}
single_quant <- normalize.quantiles(as.matrix(molecules_single_cpm))
```

## Loess normalization

[Lovén et al. 2014][Lovén2014] used a loess regression to normalize expression data with the ERCC probes.
Below is their description:

> We used a loess regression to renormalize these MAS5 normalized probe set values by using only the spike-in probe sets to fit the loess. The affy package provides a function, loess.normalize, which will perform loess regression on a matrix of values (defined by using the parameter mat) and allows for the user to specify which subset of data to use when fitting the loess (defined by using the parameter subset, see the affy package documentation for further details). For this application, the parameters mat and subset were set as the MAS5-normalized values and the row indices of the ERCC control probe sets, respectively. The default settings for all other parameters were used. The result of this was a matrix of expression values normalized to the control ERCC probes.

[Lovén2014]: http://www.sciencedirect.com/science/article/pii/S0092867412012263

[Risso et al. 2014][Risso2014] argue that regression-based approaches like this and the linear shift performed above do not work well:

> The good performance of RUVg compared to global-scaling and regression-based normalization can be explained by the different assumptions underlying each approach. Global-scaling and regression-based normalization methods assume that unwanted technical effects (i.e., between-sample differences excluding biological effects of interest) are roughly the same for genes and spike-ins and are captured by either a single parameter per sample or a regression function between pairs of samples. Such assumptions were clearly violated for our data sets (e.g., Fig. 4d). RUVg, on the other hand, only assumes that the factors of unwanted variation estimated from the spike-ins span the same linear space as the factors of unwanted variation W for all of the genes. 

```{r bulk-loess}
# From the package affy
bulk_loess <- normalize.loess(mat = as.matrix(reads_bulk_cpm),
                              subset = ercc_rows_bulk, log.it = FALSE)
```

There is an issue with the ercc controls when trying to perform loess regression.
It appears fine when there is no subsetting, but it takes so long to run I didn't let it finish.
Since the loess regression on the bulk samples gives a similar to result to the linear shift (not surprisingly since they are both regression-based methods), this does not seem worth the effort to debug.
The code below is a record of what I tried and is not evaluated.

```{r single-loess, eval=FALSE}
single_loess <- normalize.loess(mat = as.matrix(molecules_single_cpm),
                                subset = ercc_rows_single, log.it = FALSE)
```

## PCA comparison

These analyses exclude the ERCC controls.

### bulk log2 reads per million

Raw bulk data:

```{r pca-bulk-raw}
pca_bulk_raw <- run_pca(reads_bulk_cpm[gene_rows_bulk, ])
plot_pca(pca_bulk_raw$PCs, explained = pca_bulk_raw$explained,
         metadata = anno_bulk, color = "individual",
         shape = "batch", factors = c("individual", "batch"))
```

Normalized with a linear shift bulk data:

```{r pca-bulk-norm}
pca_bulk_norm <- run_pca(bulk_norm[gene_rows_bulk, ])
plot_pca(pca_bulk_norm$PCs, explained = pca_bulk_norm$explained,
         metadata = anno_bulk, color = "individual",
         shape = "batch", factors = c("individual", "batch"))
```

RUVg-normalized bulk data with k = 1:

```{r pca-bulk-ruv-k1}
pca_bulk_ruv_k1 <- run_pca(bulk_ruv_cpm_k1[gene_rows_bulk, ])
plot_pca(pca_bulk_ruv_k1$PCs, explained = pca_bulk_ruv_k1$explained,
         metadata = anno_bulk, color = "individual",
         shape = "batch", factors = c("individual", "batch"))
```

RUVg-normalized bulk data with k = 5:

```{r pca-bulk-ruv-k5}
pca_bulk_ruv_k5 <- run_pca(bulk_ruv_cpm_k5[gene_rows_bulk, ])
plot_pca(pca_bulk_ruv_k5$PCs, explained = pca_bulk_ruv_k5$explained,
         metadata = anno_bulk, color = "individual",
         shape = "batch", factors = c("individual", "batch"))
```

Quantile-normalized bulk data:

```{r pca-bulk-quant}
pca_bulk_quant <- run_pca(bulk_quant[gene_rows_bulk, ])
plot_pca(pca_bulk_quant$PCs, explained = pca_bulk_quant$explained,
         metadata = anno_bulk, color = "individual",
         shape = "batch", factors = c("individual", "batch"))
```

Loess-normalized bulk data:

```{r pca-bulk-loess}
pca_bulk_loess <- run_pca(bulk_loess[gene_rows_bulk, ])
plot_pca(pca_bulk_loess$PCs, explained = pca_bulk_loess$explained,
         metadata = anno_bulk, color = "individual",
         shape = "batch", factors = c("individual", "batch"))
```

### single log2 molecules per million

Raw single cell data:

```{r pca-single-raw}
pca_single_raw <- run_pca(molecules_single_cpm[gene_rows_single, ])
plot_pca(pca_single_raw$PCs, explained = pca_single_raw$explained,
         metadata = anno_single, color = "individual",
         shape = "batch", factors = c("individual", "batch"))
```

Normalized with a linear shift single cell data:

```{r pca-single-norm}
pca_single_norm <- run_pca(single_norm[gene_rows_single, ])
plot_pca(pca_single_norm$PCs, explained = pca_single_norm$explained,
         metadata = anno_single, color = "individual",
         shape = "batch", factors = c("individual", "batch"))
```

RUVg-normalized single cell data with k = 1:

```{r pca-single-ruv-k1}
pca_single_ruv_k1 <- run_pca(single_ruv_cpm_k1[gene_rows_single, ])
plot_pca(pca_single_ruv_k1$PCs, explained = pca_single_ruv_k1$explained,
         metadata = anno_single, color = "individual",
         shape = "batch", factors = c("individual", "batch"))
```

RUVg-normalized single cell data with k = 5:

```{r pca-single-ruv-k5}
pca_single_ruv_k5 <- run_pca(single_ruv_cpm_k5[gene_rows_single, ])
plot_pca(pca_single_ruv_k5$PCs, explained = pca_single_ruv_k5$explained,
         metadata = anno_single, color = "individual",
         shape = "batch", factors = c("individual", "batch"))
```

RUVg-normalized single cell data with k = 10:

```{r pca-single-ruv-k10}
pca_single_ruv_k10 <- run_pca(single_ruv_cpm_k10[gene_rows_single, ])
plot_pca(pca_single_ruv_k10$PCs, explained = pca_single_ruv_k10$explained,
         metadata = anno_single, color = "individual",
         shape = "batch", factors = c("individual", "batch"))
```

RUVg-normalized single cell data with k = 30:

```{r pca-single-ruv-k30}
pca_single_ruv_k30 <- run_pca(single_ruv_cpm_k30[gene_rows_single, ])
plot_pca(pca_single_ruv_k30$PCs, explained = pca_single_ruv_k30$explained,
         metadata = anno_single, color = "individual",
         shape = "batch", factors = c("individual", "batch"))
```

Quantile-normalized single cell data:

```{r pca-single-quant}
pca_single_quant <- run_pca(single_quant[gene_rows_single, ])
plot_pca(pca_single_quant$PCs, explained = pca_single_quant$explained,
         metadata = anno_single, color = "individual",
         shape = "batch", factors = c("individual", "batch"))
```

## Session information

```{r info}
sessionInfo()
```
