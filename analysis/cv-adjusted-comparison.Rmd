---
title: "Per gene comparison of CVs"
author: "Joyce Hsiao"
date: 2015-10-29
---

**Last updated:** `r Sys.Date()`

**Code version:** `r system("git log -1 --format='%H'", intern = TRUE)`

```{r chunk-options, include=FALSE}
source("chunk-options.R")

library(knitr)
opts_chunk$set(message = FALSE, warning = FALSE, eval = TRUE, 
               echo = TRUE)
```


## Objective

Per gene analysis of individual differences in coefficients of variation. We first compute the deviation to the median for each individual's CV. Then, for each gene, we compute two meausures to quantify the variabilty of the CVs: sum of squared deviation and sum of absolute deviation. Then, to get a confidence of this estimate, we perform bootstraping within each individual; this step perserves the individual differences in mean and yet allow us to get a sample estimate of the variances. 


## Set up

```{r, message=FALSE, warning=FALSE}
library("data.table")
library("dplyr")
library("limma")
library("edgeR")
library("ggplot2")
library("grid")
theme_set(theme_bw(base_size = 12))
source("functions.R")
```


## Prepare data

Input annotation of only QC-filtered single cells. Remove NA19098.r2

```{r}
anno_qc <- read.table("../data/annotation-filter.txt", header = TRUE,
                   stringsAsFactors = FALSE)
is_include <- anno_qc$batch != "NA19098.r2"
anno_qc_filter <- anno_qc[which(is_include), ]
```


Import endogeneous gene molecule counts that are QC-filtered, CPM-normalized, ERCC-normalized, and also processed to remove unwanted variation from batch effet. ERCC genes are removed from this file.

```{r}
molecules_ENSG <- read.table("../data/molecules-final.txt", header = TRUE, stringsAsFactors = FALSE)
molecules_ENSG <- molecules_ENSG[ , is_include]
```

Input moleclule counts before log2 CPM transformation. This file is used to compute percent zero-count cells per sample.

```{r}
molecules_sparse <- read.table("../data/molecules-filter.txt", header = TRUE, stringsAsFactors = FALSE)

molecules_sparse <- molecules_sparse[grep("ENSG", rownames(molecules_sparse)), ]
stopifnot( all.equal(rownames(molecules_ENSG), rownames(molecules_sparse)) )
```


## Compute normalized CV 

We compute squared CV across cells for each individual and then for each individual CV profile, account for mean dependency by computing distance with respect to the data-wide coefficient variation on the log10 scale. 

```{r}
source("../code/cv-functions.r")

ENSG_cv <- compute_cv(log2counts = molecules_ENSG,
                      grouping_vector = anno_qc_filter$individual)

ENSG_cv_adj <- normalize_cv(group_cv = ENSG_cv, 
                            log2counts = molecules_ENSG, 
                            anno = anno_qc_filter)
```

## Compute summary measure of deviation 

Standardize the each CV vectors

```{r}
df_cv <- data.frame(NA19098 = ENSG_cv_adj[[1]]$log10cv2_adj,
                    NA19101 = ENSG_cv_adj[[2]]$log10cv2_adj,
                    NA19239 = ENSG_cv_adj[[3]]$log10cv2_adj)

library(matrixStats)
df_norm <- sweep(df_cv, MARGIN = 2, STATS = colMeans(as.matrix(df_cv)), FUN = "-")
df_norm <- sweep(df_norm, MARGIN = 2, STATS = sqrt(colVars(as.matrix(df_cv))), FUN = "/")
colnames(df_norm) <- names(ENSG_cv_adj)
```

Compare gene adj-CVs before/after standardization.

Genes marked red rank top 10 in the standardized DM (deviation-from-the-median), which is also referred to as adjusted coefficient of variation.

```{r}
par(mfrow = c(1,2))
plot(x = df_cv[[1]], y = df_cv[[2]], main = "Adjusted log10 CV^2",
     xlab = "NA19238", ylab = "NA19101")
points(x = df_cv[[1]][1:10], y = df_cv[[2]][1:10], col = "red", cex = .8, pch = 16)
plot(x = df_norm[[1]], y = df_norm[[2]], main = "Adjusted log10 CV^2, standardized",
     xlab = "NA19238", ylab = "NA19101")
points(x = df_norm[[1]][1:10], y = df_norm[[2]][1:10], col = "red", cex = .8, pch = 16)
```


Compute distance

```{r}
library(matrixStats)

df_norm <- as.data.frame(df_norm)
df_norm$squared_dev <- rowSums( ( df_norm - rowMedians(as.matrix(df_norm)) )^2 )
df_norm$abs_dev <- rowSums(abs( df_norm - rowMedians(as.matrix(df_norm)) ))
```

*Gene with the largest SSM (Sum-of-Squared-Deviation-from-the-median). 

```{r}
library(broman)
crayon <- brocolors("crayon")
library(scales)

gene <- rownames(molecules_ENSG)[ order(df_norm$squared_dev, decreasing = TRUE)[1]]

# Compute density for individual gene expression 
dens <- lapply(1:3, function(ii_individual) {
   density( unlist(molecules_ENSG[ rownames(molecules_ENSG) == gene,
        anno_qc_filter$individual == unique(anno_qc_filter$individual)[ii_individual]]) )
  })
names(dens) <- unique(anno_qc_filter$individual)
xlims <- c(range( sapply(dens, "[[", 1) ) )
ylims <- c(0, max( sapply(dens, "[[", 2) ) )

par(mfrow = c(1,1))
plot(0, pch = "", 
     xlab = "log2 gene expression", main = "",
     ylab = "Density", axes = F, xlim = xlims, ylim = ylims)
axis(1); axis(2)
polygon(dens[[1]], col = alpha( crayon["Blue Bell"], .3), lwd = .5 )
polygon(dens[[2]], col = alpha( crayon["Fern"], .3), lwd = .5)
polygon(dens[[3]], col = alpha( crayon["Sunglow"], .2), lwd = .5 )
title("")


```

## Permutatoin

Permute cell labels. An idea for hypothesis testing..

```{r, eval = FALSE}
source("../code/bootstrap-cells.r")

# Make permuted data sets
permuted_data <- permute_cells(log2counts = molecules_ENSG, 
                               grouping_vector = anno_qc_filter$individual, 
                               num_permute = 5)

# Compute adjusted CV for the permuted data
source("../code/cv-functions.r")

permuted_cv_adj <- lapply(permuted_data, function(per_data) {
  perm_cv <- compute_cv(log2counts = per_data,
                      grouping_vector = anno_qc_filter$individual)

  perm_cv_adj <- normalize_cv(group_cv = perm_cv, 
                            log2counts = per_data, 
                            anno = anno_qc_filter)
  
  df_perm <- cbind(perm_cv_adj[[1]]$log10cv2_adj, 
                   perm_cv_adj[[2]]$log10cv2_adj,
                   perm_cv_adj[[3]]$log10cv2_adj)
  
  # Standardize CVs
  df_norm <- sweep(df_perm, MARGIN = 2, STATS = colMeans(as.matrix(df_perm)), FUN = "-")
  df_norm <- sweep(df_perm, MARGIN = 2, STATS = sqrt(colVars(as.matrix(df_perm))), FUN = "/")
  return(df_norm)
})


permuted_distance <- lapply(permuted_cv_adj, function(per_data) {
  squared_dev <- rowSums( ( per_data - rowMedians(as.matrix(per_data)) )^2 )
  abs_dev <- rowSums(abs( per_data - rowMedians(as.matrix(per_data)) ))
  list(squared_dev = squared_dev,
       abs_dev = abs_dev)
})
```

Individual means/variances in each permuted data set.


```{r}
permuted_summary <- lapply(permuted_data, function(per_data) {
  sum_info <- lapply(1:dim(per_data)[1], function(ii_gene) {
        gene_mean <- aggregate(as.matrix(per_data)[ii_gene, ] ~ anno_qc_filter$individual,
                              FUN = mean)
        gene_sd <- aggregate(as.matrix(per_data)[ii_gene, ] ~ anno_qc_filter$individual,
                              FUN = sd)
        list(gene_mean = gene_mean, gene_sd = gene_sd)
})
  means <- do.call(rbind, means)  
  means
}
  per_data[ , anno_qc_filter$individual == unique(anno_qc_filter$individual)[p]]
}
ggplot(data.frame(do.call(rbind, permuted_cv_adj[[1]]),
        aes(x = log10(mean), y = log10(cv^2))) +
   geom_point(aes(col = individual)) +
   ggtitle("Permutation-based CV")

ggplot(data.frame(do.call(rbind, permuted_cv_adj[[1]]),
       aes(x = log10(mean), y = log10cv2_adj)) +
   geom_point(aes(col = individual)) +
   ggtitle("Permutation-based adjusted CV")

```

Compute empirical p-values

```{r}
load("rda/permuted_data.rda")

df_norm$squared_dev
df_norm$abs_dev


```

Distribution of empirical p-values


```{r}

```


## Investigation...



## Session information

```{r info}
sessionInfo()
```
