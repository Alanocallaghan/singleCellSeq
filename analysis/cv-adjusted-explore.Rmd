---
title: "Compare CVs: explore significant genes"
author: "Joyce Hsiao"
date: 2015-10-13
---

**Last updated:** `r Sys.Date()`

**Code version:** `r system("git log -1 --format='%H'", intern = TRUE)`

```{r chunk-options, include=FALSE}
source("chunk-options.R")

library(knitr)
opts_chunk$set(message = FALSE, warning = FALSE, eval = TRUE, 
               echo = TRUE)
```


## Objective

Previously, we normalized coefficient of variations across samples and showed that this normalized measure is independent of mean moleucle count and also percent of zero-count cells.

Here we will look more into the annotations of these genes; specifically, among the genes that we observe significant individual differences, is there any cell-cycle genes pluripotent genes?


## Model

$$log10(CV^2_{gk}) = log10(CV^2_g) + \epsilon_{gk}$$

where $\epsilon_{gk}$ is independent distributed as a normal random variables
for each gene $g$ and sample $k$.

Equivalent, 

$$log10(\frac{\sigma^2_{gk}}{\mu^2_{gk}}) = log10(\frac{\sigma^2_{g}}{\mu^2_{g}}) + \epsilon_{gk}$$


## Set up

```{r, message=FALSE, warning=FALSE}
library("data.table")
library("dplyr")
library("limma")
library("edgeR")
library("ggplot2")
library("grid")
theme_set(theme_bw(base_size = 12))
source("functions.R")
```



## Prepare data


Input annotation of only QC-filtered single cells

```{r}
anno_qc <- read.table("../data/annotation-filter.txt", header = TRUE,
                   stringsAsFactors = FALSE)
head(anno_qc)
```


Input molecule counts that are filtered, transformed, and also processed to remove unwanted variation from batch effet. ERCC genes are also removed.

```{r}
molecules_qc <- read.table("../data/molecules-final.txt", header = TRUE, stringsAsFactors = FALSE)
```

Input moleclule counts before log2 CPM transformation.

```{r}
molecules_filter <- read.table("../data/molecules-filter.txt", header = TRUE, stringsAsFactors = FALSE)
molecules_filter <- molecules_filter[which(rownames(molecules_filter) %in% rownames(molecules_qc)), ]

stopifnot(dim(molecules_filter) == dim(molecules_qc))
```


## Compute coefficient of variation

Compute per batch coefficient of variation.

Include only genes with positive coefficient of variation. Some genes in this data may have zero coefficient of variation, because we include gene with more than 0 count 
across all cells.


```{r}
molecules_cv_batch <- 
  lapply(1:length(unique(anno_qc$batch)), function(per_batch) {
      molecules_per_batch <- 2^molecules_qc[ , unique(anno_qc$batch) == unique(anno_qc$batch)[per_batch] ]
      mean_per_gene <- apply(molecules_per_batch, 1, mean, na.rm = TRUE)
      sd_per_gene <- apply(molecules_per_batch, 1, sd, na.rm = TRUE)
      cv_per_gene <- data.frame(mean = mean_per_gene,
                                sd = sd_per_gene,
                                cv = sd_per_gene/mean_per_gene)
      rownames(cv_per_gene) <- rownames(molecules_qc)
  
      cv_per_gene <- cv_per_gene[rowSums(is.na(cv_per_gene)) == 0, ]
      cv_per_gene$batch <- unique(anno_qc$batch)[per_batch]
      
      # Add sparsity percent
      molecules_count <- molecules_filter[ , unique(anno_qc$batch) == unique(anno_qc$batch)[per_batch]]
      cv_per_gene$sparse <- rowMeans(as.matrix(molecules_count) == 0)
        
      return(cv_per_gene)
      }) 
names(molecules_cv_batch) <- unique(anno_qc$batch)

dim(molecules_cv_batch[[1]])
```



## Compute normalized CV

Merge summary data.frames.

```{r}
df_plot <- do.call(rbind, molecules_cv_batch)
```

Compute rolling medians.


```{r}
library(zoo)
# Compute a data-wide coefficient of variation on CPM normalized counts.
data_cv <- apply(2^molecules_qc, 1, sd)/apply(2^molecules_qc, 1, mean)

# Order of genes by mean expression levels
order_gene <- order(apply(2^molecules_qc, 1, mean))

# Rolling medians of log10 squared CV by mean expression levels
roll_medians <- rollapply(log10(data_cv^2)[order_gene], width = 50, by = 25,
                         FUN = median, fill = list("extend", "extend", "NA") )
ii_na <- which( is.na(roll_medians) )
roll_medians[ii_na] <- median( log10(data_cv^2)[order_gene][ii_na] )

names(roll_medians) <- rownames(molecules_qc)[order_gene]

# re-order rolling medians
reorder_gene <- match(rownames(molecules_qc), names(roll_medians) )
head(reorder_gene)
roll_medians <- roll_medians[ reorder_gene ]

head(names(roll_medians))
head(rownames(molecules_qc))
```

Double-check the computation of rolling median.

```{r}
ggplot(data.frame(cv2 = log10(data_cv^2), 
                  roll_medians = roll_medians,
                  mean = log10(apply(2^molecules_qc, 1, mean) ) ) )+
  geom_point(aes(x = mean, y = cv2), col = "red") +
  geom_point(aes(x = mean, y = roll_medians), col = "blue", alpha = .7)
```


Compute adjusted coefficient of variation.

```{r}
# adjusted coefficient of variation on log10 scale
log10cv2_adj <- 
  lapply(1:length(molecules_cv_batch), function(per_batch) {
    foo <- log10(molecules_cv_batch[[per_batch]]$cv^2) - roll_medians
    return(foo)
})
df_plot$log10cv2_adj <- do.call(c, log10cv2_adj)
```



## Compare adjusted CVs

limma *lmFit* function takes log-ratios or log-expression values and does not require default normalizations methods. This is because limma was originally designed for microarray data.

```{r}
library(limma)

df_limma <- matrix(df_plot$log10cv2_adj, 
                      nrow = nrow(molecules_qc), ncol = 9, byrow = FALSE)

design <- data.frame(individual = factor(rep(unique(anno_qc$individual), each = 3) ),
                     rep = factor(rep(c(1:3), times = 3)) )

colnames(df_limma) <- with(design, paste0(individual, rep))

fit_limma <- lmFit(df_limma, design = model.matrix( ~ individual, data = design))                    
fit_limma <- eBayes(fit_limma)
```


False discover control adjutment.

```{r}
F.p.adj <- p.adjust(fit_limma$F.p.value, method = "fdr")
summary(F.p.adj)
```


Rank genes by FDR.

```{r}
order_limma <- order(F.p.adj)
```

Cutoffs

```{r}
df_cuts <- data.frame(cuts = c(.001, .01, .05, .1, .15, .2))
df_cuts$sig_count <- sapply(1:6, function(per_cut) {
                    sum(F.p.adj < df_cuts$cuts[per_cut] )
                    })
df_cuts
```


## Overlapy with pluripotency genes

Input pluripotency genes. A list of 27 pluripotency genes used to demonstrate iPSC heterogeneity in Narshinh2011 Gene ID conversion was done by using the DAVID http://david.abcc.ncifcrf.gov

```{r}
pluripotency_genes <- read.table("../data/pluripotency-genes.txt", header = TRUE, sep="\t")
```


```{r}
pluripotent_count <- lapply(1:nrow(df_cuts), function(per_cut) {
    is_pluripotent <- rownames(molecules_qc)[which(F.p.adj< df_cuts$cuts[per_cut])] %in% pluripotency_genes$To
    sum(is_pluripotent)
  })
pluripotent_count <- do.call(rbind, pluripotent_count)

rownames(pluripotent_count) <- df_cuts$cuts
kable(pluripotent_count)
```


## Overlap with cell-cycle genes

Input cell cycle gene Gene sets reflecting 5 cell cycle phases were taken from Table S2 of Macosko2015 Gene ID conversion was done by using the DAVID http://david.abcc.ncifcrf.gov

```{r}
cell_cycle_genes <- read.table("../data/cellcyclegenes.txt", header = TRUE, sep="\t")
```


```{r}
cell_cycle_count <- lapply(1:nrow(df_cuts), function(per_cut) {
  per_cycle <- sapply(1:ncol(cell_cycle_genes), function(per_cycle) {
        is_cell_cycle <- rownames(molecules_qc)[which(F.p.adj< df_cuts$cuts[per_cut])] %in% cell_cycle_genes[[per_cycle]]
        sum(is_cell_cycle)
  })
})
cell_cycle_count <- do.call(rbind, cell_cycle_count)

colnames(cell_cycle_count) <- colnames(cell_cycle_genes)
rownames(cell_cycle_count) <- df_cuts$cuts
cell_cycle_count <- cbind(df_cuts, cell_cycle_count)

kable(cell_cycle_count)
```


### Gene annotations

FDR < .001

```{r}
library(knitr)
library(mygene)

kable(queryMany(rownames(molecules_qc)[which(F.p.adj< .001)], scopes="ensembl.gene", 
                 fields=c("name", "summary"), species="human") )
```




## Session information

```{r info}
sessionInfo()
```
