---
title: "Compare CVs: explore significant genes"
author: "Joyce Hsiao"
date: 2015-10-14
---

**Last updated:** `r Sys.Date()`

**Code version:** `r system("git log -1 --format='%H'", intern = TRUE)`

```{r chunk-options, include=FALSE}
source("chunk-options.R")

library(knitr)
opts_chunk$set(message = FALSE, warning = FALSE, eval = TRUE, 
               echo = TRUE)
```


## Objective

Previously, we normlaized CVs ([link1]) and used a per gene linear model to compare normalized coefficient of variations across individuals ([link2]). 

In this document, we cross-reference the top significant differential CV genes with cell-cycle genes and pluripotent genes. Results suggest genes indicating cell cycle and pluripotency have little cell-to-cell heterogeneity across individuals.

[link1]: http://jdblischak.github.io/singleCellSeq/analysis/cv-adjusted.html
[link2]: http://jdblischak.github.io/singleCellSeq/analysis/cv-adjusted-all-genes.html


## Set up

```{r, message=FALSE, warning=FALSE}
library("data.table")
library("dplyr")
library("limma")
library("edgeR")
library("ggplot2")
library("grid")
library("zoo")
theme_set(theme_bw(base_size = 12))
source("functions.R")
```



## Prepare data

Input annotation of only QC-filtered single cells

```{r}
anno_qc <- read.table("../data/annotation-filter.txt", header = TRUE,
                   stringsAsFactors = FALSE)
head(anno_qc)
```


Input endogeneous gene molecule counts that are QC-filtered, CPM-normalized, ERCC-normalized, and also processed to remove unwanted variation from batch effet. ERCC genes are removed from this file.

```{r}
molecules_ENSG <- read.table("../data/molecules-final.txt", header = TRUE, stringsAsFactors = FALSE)
```

Input ERCC gene moleclue counts that are QC-filtered and CPM-normalized. 

```{r}
molecules_ERCC <- read.table("../data/molecules-cpm-ercc.txt", header = TRUE, stringsAsFactors = FALSE)
```

Combine endogeneous and ERCC genes.

```{r}
molecules_all_genes <- rbind(molecules_ENSG, molecules_ERCC)
```


Input endogeneous and ERCC gene moleclule counts before log2 CPM transformation. This file is used to compute percent zero-count cells per sample.

```{r}
molecules_filter <- read.table("../data/molecules-filter.txt", header = TRUE, stringsAsFactors = FALSE)

stopifnot( all.equal(rownames(molecules_all_genes), rownames(molecules_filter)) )
```



## Normalize coefficient of variation

Compute coefficient of variation.

```{r}
# Compute CV and mean of normalized molecule counts (take 2^(log2-normalized count))

molecules_cv_batch <- 
  lapply(1:length(unique(anno_qc$batch)), function(per_batch) {
      molecules_per_batch <- 2^molecules_all_genes[ , unique(anno_qc$batch) == unique(anno_qc$batch)[per_batch] ]
      mean_per_gene <- apply(molecules_per_batch, 1, mean, na.rm = TRUE)
      sd_per_gene <- apply(molecules_per_batch, 1, sd, na.rm = TRUE)
      cv_per_gene <- data.frame(mean = mean_per_gene,
                                sd = sd_per_gene,
                                cv = sd_per_gene/mean_per_gene)
      rownames(cv_per_gene) <- rownames(molecules_all_genes)
  
      # cv_per_gene <- cv_per_gene[rowSums(is.na(cv_per_gene)) == 0, ]
      cv_per_gene$batch <- unique(anno_qc$batch)[per_batch]
      
      # Add sparsity percent
      molecules_count <- molecules_filter[ , unique(anno_qc$batch) == unique(anno_qc$batch)[per_batch]]
      cv_per_gene$sparse <- rowMeans(as.matrix(molecules_count) == 0)
        
      return(cv_per_gene)
      }) 
names(molecules_cv_batch) <- unique(anno_qc$batch)

sapply(molecules_cv_batch, dim)
```


Merge summary data.frames.

```{r}
df_plot <- do.call(rbind, molecules_cv_batch)
```

Compute rolling medians across all samples.

```{r}
# Compute a data-wide coefficient of variation on CPM normalized counts.
data_cv <- apply(2^molecules_all_genes, 1, sd)/apply(2^molecules_all_genes, 1, mean)

# Order of genes by mean expression levels
order_gene <- order(apply(2^molecules_all_genes, 1, mean))

# Rolling medians of log10 squared CV by mean expression levels
roll_medians <- rollapply(log10(data_cv^2)[order_gene], width = 50, by = 25,
                         FUN = median, fill = list("extend", "extend", "NA") )
ii_na <- which( is.na(roll_medians) )
roll_medians[ii_na] <- median( log10(data_cv^2)[order_gene][ii_na] )

names(roll_medians) <- rownames(molecules_all_genes)[order_gene]

# re-order rolling medians
reorder_gene <- match(rownames(molecules_all_genes), names(roll_medians) )
head(reorder_gene)
roll_medians <- roll_medians[ reorder_gene ]

stopifnot( all.equal(names(roll_medians), rownames(molecules_all_genes) ) )
```


Compute adjusted coefficient of variation.

```{r}
# adjusted coefficient of variation on log10 scale
log10cv2_adj <- 
  lapply(1:length(molecules_cv_batch), function(per_batch) {
    foo <- log10(molecules_cv_batch[[per_batch]]$cv^2) - roll_medians
    return(foo)
})
df_plot$log10cv2_adj <- do.call(c, log10cv2_adj)
df_plot$is_ERCC <- ( 1:dim(df_plot)[1] %in% grep("ERCC", rownames(df_plot)) )
```



## limma


```{r}
library(limma)

df_limma <- matrix(df_plot$log10cv2_adj, 
                      nrow = nrow(molecules_all_genes), ncol = 9, byrow = FALSE)

design <- data.frame(individual = factor(rep(unique(anno_qc$individual), each = 3) ),
                     rep = factor(rep(c(1:3), times = 3)) )

colnames(df_limma) <- with(design, paste0(individual, rep))

fit_limma <- lmFit(df_limma, design = model.matrix( ~ individual, data = design))                      
fit_limma <- eBayes(fit_limma)
```

False discover control adjutment.

```{r}
F.p.adj <- p.adjust(fit_limma$F.p.value, method = "fdr")
summary(F.p.adj)
```

Cutoffs

```{r}
df_cuts <- data.frame(cuts = c(.001, .01, .05, .1, .15, .2))
df_cuts$sig_count <- sapply(1:6, function(per_cut) {
                    sum(F.p.adj < df_cuts$cuts[per_cut] )
                    })
df_cuts
```


## Overlapy with pluripotency genes

Input pluripotency genes. A list of 27 pluripotency genes used to demonstrate iPSC heterogeneity in Narshinh2011 Gene ID conversion was done by using the DAVID http://david.abcc.ncifcrf.gov

```{r}
pluripotency_genes <- read.table("../data/pluripotency-genes.txt", header = TRUE, sep="\t")
```


```{r}
pluripotent_count <- lapply(1:nrow(df_cuts), function(per_cut) {
    is_pluripotent <- rownames(molecules_all_genes)[which(F.p.adj< df_cuts$cuts[per_cut])] %in% pluripotency_genes$To
    sum(is_pluripotent)
  })
pluripotent_count <- do.call(rbind, pluripotent_count)

rownames(pluripotent_count) <- df_cuts$cuts
kable(pluripotent_count)
```


## Overlap with cell-cycle genes

Input cell cycle gene Gene sets reflecting 5 cell cycle phases were taken from Table S2 of Macosko2015 Gene ID conversion was done by using the DAVID http://david.abcc.ncifcrf.gov

```{r}
cell_cycle_genes <- read.table("../data/cellcyclegenes.txt", header = TRUE, sep="\t")
```


```{r}
cell_cycle_count <- lapply(1:nrow(df_cuts), function(per_cut) {
  per_cycle <- sapply(1:ncol(cell_cycle_genes), function(per_cycle) {
        is_cell_cycle <- rownames(molecules_all_genes)[which(F.p.adj< df_cuts$cuts[per_cut])] %in% cell_cycle_genes[[per_cycle]]
        sum(is_cell_cycle)
  })
})
cell_cycle_count <- do.call(rbind, cell_cycle_count)

colnames(cell_cycle_count) <- colnames(cell_cycle_genes)
rownames(cell_cycle_count) <- df_cuts$cuts
cell_cycle_count <- cbind(df_cuts, cell_cycle_count)

kable(cell_cycle_count)
```


### Gene annotations

For genes that we found to have FDR < .001 (54 genes) in our analysis comparing coefficient of variations between individuals, we look up the gene annotations as follows

```{r}
library(knitr)
library(biomaRt)

ensembl <- useMart(host = "grch37.ensembl.org",
                   biomart = "ENSEMBL_MART_ENSEMBL",
                   dataset = "hsapiens_gene_ensembl")

diff_cv_genes <- rownames(molecules_all_genes)[which(F.p.adj< .001)]

diff_cv_genes_info <- getBM(attributes = c("ensembl_gene_id", "chromosome_name",
                                           "external_gene_name", "transcript_count",
                                           "description"),
                            filters = "ensembl_gene_id",
                            values = diff_cv_genes[grep("ENSG", diff_cv_genes)],
                            mart = ensembl)
kable(diff_cv_genes_info)
```




## Session information

```{r info}
sessionInfo()
```
