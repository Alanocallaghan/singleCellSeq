---
title: "Data transformation"
date: 2015-09-30
---

**Last updated:** `r Sys.Date()`

**Code version:** `r system("git log -1 --format='%H'", intern = TRUE)`

```{r chunk-options, include=FALSE}
source("chunk-options.R")
opts_chunk$set(fig.width = 8, fig.height = 8)
```

```{r packages, message=FALSE}
library("data.table")
library("dplyr")
library("edgeR")
```

This file performs the transformations and outputs various intermediate data files used for our analysis.

Creates the following files:

*  anno.txt - Annotation file
*  molecules.txt - Molecule counts (sample x gene)
*  reads.txt - Read counts (sample x gene)
*  molecules-per-lane.txt (sample x gene) - the inflated molecule counts obtained by summing each lane (for QC purposes)

## Start with raw gene counts

We start with the gene counts file produced by our [pipeline for processing the sequencing data](process-samples.html).

```{r input, cache = TRUE}
counts <- fread("/mnt/gluster/data/internal_supp/singleCellSeq/gene-counts.txt")
```

It is a very large file, and when read into R it uses `r format(object.size(counts), units = "GB")` of memory.
Each row corresponds to a specific sample processed in a specific manner.

```{r inspect}
counts %>% select(1:10) %>% slice(1:10)
```

This granular data is used for performing [quality control at the level of sequencing lane](qc-by-lane.html).

## Sum counts per lane by sample

For downstream analyses, we need to sum the number of reads or molecules for every gene for each sample across sequencing runs.
The molecule counts derived using this method will be inflated because duplicate reads (i.e. have the same UMI and start site) will only be removed within a lane.
Thus these per-lane molecule count levels are only used for QC purposes.

```{r summarise}
counts_by_sample <- counts %>%
  filter(!is.na(lane), sickle == "quality-trimmed") %>%
  select(individual, batch, well, rmdup, starts_with("ENSG"), starts_with("ERCC")) %>%
  group_by(individual, batch, well, rmdup) %>%
  summarise_each(funs(sum)) %>%
  arrange(individual, batch, well, rmdup) %>%
  ungroup
```

## Create annotation file

The annotation file contains the meta-information for each sample.

```{r annotation}
anno <- counts_by_sample %>%
  filter(rmdup == "molecules") %>%
  select(individual:well) %>%
  as.data.frame
anno$sample_id <- paste(paste0("NA", anno$individual), anno$batch, anno$well,
                        sep = ".")
head(anno)
```

Output annotation file.

```{r write-anno}
write.table(anno, "../data/annotation.txt", quote = FALSE, sep = "\t",
            row.names = FALSE)
```

## Create reads file

The reads file contains only the counts.
Each row is a gene and each column is a sample.
The columns in the reads file correspond to the rows in the annotation file.

```{r transpose-reads}
reads <- counts_by_sample %>%
  filter(rmdup == "reads") %>%
  select(-(individual:rmdup)) %>%
  t
dim(reads)
colnames(reads) <- anno$sample_id
reads[1:10, 1:5]
```

Only genes with at least one read observed in at least one of the single cell or bulk samples are maintained.

```{r genes-observed}
genes_observed <- rownames(reads)[rowSums(reads) > 0]
reads <- reads[rownames(reads) %in% genes_observed, ]
```

There are `r length(genes_observed)` genes with at least one read.

Separate the bulk samples from the single cells.

```{r separate-bulk-reads}
reads_bulk <- reads[, anno$well == "bulk"]
reads <- reads[, anno$well != "bulk"]
stopifnot(ncol(reads_bulk) == 3 * 3, ncol(reads) == 3 * 3 * 96)
```

Output read counts.

```{r output-reads}
write.table(reads, "../data/reads.txt", quote = FALSE, sep = "\t",
            col.names = NA)
write.table(reads_bulk, "../data/reads-bulk.txt", quote = FALSE, sep = "\t",
            col.names = NA)
```

## Create molecules per lane file

Create a molecules per lane file similar to the reads file.

```{r transpose-molecules-per-lane}
molecules_per_lane <- counts_by_sample %>%
  filter(rmdup == "molecules") %>%
  select(-(individual:rmdup)) %>%
  t
dim(molecules_per_lane)
colnames(molecules_per_lane) <- anno$sample_id
```

Only genes with at least one read observed in at least one of the single cell or bulk samples are maintained.

```{r filter-genes-observed-molecules-per-lane}
molecules_per_lane <- molecules_per_lane[rownames(molecules_per_lane) %in% genes_observed, ]
stopifnot(nrow(molecules_per_lane) == nrow(reads))
```

Output molecule per lane counts.

```{r output-molecules-per-lane}
write.table(molecules_per_lane, "../data/molecules-per-lane.txt", quote = FALSE, sep = "\t",
            col.names = NA)
```

## Create molecules file

Reads with the same UMI and start position need to be removed using all the data for a given sample.
Otherwise the counts will be inflated because the same read can be sequenced across multiple lanes.
Post-mapping we combined all the reads per sample and removed duplicate UMIs ([pipeline][]).
The data from these combined samples have `NA` recorded for index, lane, and flow_cell.

[pipeline]: http://jdblischak.github.io/singleCellSeq/analysis/process-samples.html#process-at-the-sample-level

```{r select-sort-combined-counts}
counts_combined <- counts %>%
  filter(is.na(lane), sickle == "quality-trimmed") %>%
  select(individual, batch, well, rmdup, starts_with("ENSG"), starts_with("ERCC")) %>%
  arrange(individual, batch, well, rmdup)
stopifnot(counts_combined$individual[c(TRUE, FALSE)] == anno$individual,
          counts_combined$batch[c(TRUE, FALSE)] == anno$batch,
          counts_combined$well[c(TRUE, FALSE)] == anno$well)
```

Create molecules file similar to reads file.

```{r transpose-molecules}
molecules <- counts_combined %>%
  filter(rmdup == "molecules") %>%
  select(-(individual:rmdup)) %>%
  t
dim(molecules)
colnames(molecules) <- anno$sample_id
```

Only genes with at least one read observed in at least one of the single cell or bulk samples are maintained.

```{r filter-genes-observed-molecules}
molecules <- molecules[rownames(molecules) %in% genes_observed, ]
stopifnot(nrow(molecules) == nrow(reads))
```

Remove bulk samples from molecules file.
Because bulk samples have many more molecules than a single cell, the UMIs are not valid.

```{r remove-bulk-molecules}
molecules <- molecules[, anno$well != "bulk"]
stopifnot(ncol(molecules) == 3 * 3 * 96)
```

Output molecule counts.

```{r output-molecules}
write.table(molecules, "../data/molecules.txt", quote = FALSE, sep = "\t",
            col.names = NA)
```

## Filter cells

We performed [quality control at the level of single cell samples](qc-cell-ipsc.html) to identify low quality single cells.

Input list of quality single cells.

```{r input-quality-single-cells}
quality_single_cells <- scan("../data/quality-single-cells.txt",
                             what = "character")
```

We filter the annotation, reads, and molecules data to only include quality single cells.
Note that this means the filtered annotation file no longer contains information of the bulk samples.

```{r filter-quality-cells}
anno_filter <- anno %>% filter(sample_id %in% quality_single_cells)
reads_filter <- reads[, colnames(reads) %in% quality_single_cells]
molecules_filter <- molecules[, colnames(molecules) %in% quality_single_cells]
stopifnot(nrow(anno_filter) == ncol(reads_filter),
          nrow(anno_filter) == ncol(molecules_filter),
          anno_filter$sample_id == colnames(reads_filter),
          anno_filter$sample_id == colnames(molecules_filter))
```

The number of good quality cells is not even across batches.

```{r good-cells-per-batch}
table(anno_filter$individual, anno_filter$batch)
```

## Filter genes

We filter the genes to exlude both those that are lowly expressed or over-expressed (>= 1024 molecules in a given cell).

We identify the lower cutoff using the mean log~2~ molecule counts per million (cpm) in the `r length(quality_single_cells)` high quality single cells.

```{r identify-lower-expression-cutoff}
molecules_cpm_mean <- rowMeans(cpm(molecules_filter, log = TRUE))
hist(molecules_cpm_mean, xlab = "Mean log2 molecule cpm in single cells",
     ylab = "Number of genes", main = "Identifying expression cutoff")
lower_exp_cutoff <- 2
abline(v = lower_exp_cutoff, col = "red")
genes_pass_filter <- rownames(molecules_filter)[molecules_cpm_mean > lower_exp_cutoff]
```

`r length(genes_pass_filter)` genes have a mean log~2~ molecule cpm greater than `r lower_exp_cutoff`,
including `r sum(grepl("ERCC", genes_pass_filter))` ERCC genes.

Next we identify any genes which have greater than 1024 molecules in any given single cell.
These are above our theoretical maximum number of UMIs (it can happen when a highly expressed gene as multiple start sites),
and thus we cannot correct them for the [collision probability](#collision-probability).

```{r identify-over-expressed}
overexpressed_rows <- apply(molecules_filter, 1, function(x) any(x >= 1024))
overexpressed_genes <- rownames(molecules_filter)[overexpressed_rows]
overexpressed_genes
```

`r length(overexpressed_genes)` genes have molecule counts greater than or equal to 1024 in at least one single cell,
including `r sum(grepl("ERCC", overexpressed_genes))`.

Update the list of genes passing the filters.

```{r update-filtered-genes}
genes_pass_filter <- setdiff(genes_pass_filter, overexpressed_genes)
```

Filter the data to only include the subset of `r length(genes_pass_filter)` genes which pass the lower and upper expression cutoffs.
This subset includes `r sum(grepl("ERCC", genes_pass_filter))` ERCC genes.

```{r filter-genes}
reads_filter <- reads_filter[rownames(reads_filter) %in% genes_pass_filter, ]
molecules_filter <- molecules_filter[rownames(molecules_filter) %in% genes_pass_filter, ]
reads_bulk_filter <- reads_bulk[rownames(reads_bulk) %in% genes_pass_filter, ]
stopifnot(nrow(reads_filter) == length(genes_pass_filter),
          dim(reads_filter) == dim(molecules_filter),
          nrow(reads_bulk_filter) == nrow(molecules_filter))
```

Output filtered data.

```{r output-filtered-data}
write.table(anno_filter, "../data/anno-filter.txt", quote = FALSE,
            sep = "\t", col.names = NA)
write.table(reads_filter, "../data/reads-filter.txt", quote = FALSE,
            sep = "\t", col.names = NA)
write.table(molecules_filter, "../data/molecules-filter.txt", quote = FALSE,
            sep = "\t", col.names = NA)
write.table(reads_bulk_filter, "../data/reads-bulk-filter.txt", quote = FALSE,
            sep = "\t", col.names = NA)
```

## Correct for collision probability

Due to the stochasticity of the sampling process, not all molecules will be tagged with a UMI and sequenced.
We correct for this "collision probability" following the method applied in [Grun et al. 2014][Grun2014].

[Grun2014]: http://www.nature.com/nmeth/journal/v11/n6/full/nmeth.2930.html#methods

```{r collision-probability}
molecules_collision <- -1024 * log(1 - molecules_filter / 1024)
```

## Calculating counts per million

We calculate the log~2~ counts per million (cpm) separately for the endogenous and ERCC genes.

```{r index-ercc-genes}
ercc_rows <- grepl("ERCC", rownames(reads_bulk_filter))
```

### Reads bulk endogenous

```{r reads-bulk-endogenous}
reads_bulk_cpm <- cpm(reads_bulk_filter[!ercc_rows, ], log = TRUE)
write.table(reads_bulk_cpm, "../data/reads-bulk-cpm.txt", quote = FALSE,
            sep = "\t", col.names = NA)
```

### Reads bulk ERCC

```{r reads-bulk-ercc}
reads_bulk_cpm_ercc <- cpm(reads_bulk_filter[ercc_rows, ], log = TRUE)
write.table(reads_bulk_cpm_ercc, "../data/reads-bulk-cpm-ercc.txt", quote = FALSE,
            sep = "\t", col.names = NA)
```

### Molecules single cell endogenous

```{r molecules-bulk-endogenous}
molecules_cpm <- cpm(molecules_filter[!ercc_rows, ], log = TRUE)
write.table(molecules_cpm, "../data/molecules-bulk-cpm.txt", quote = FALSE,
            sep = "\t", col.names = NA)
```

### Molecules single cell ERCC

```{r molecules-bulk-ercc}
molecules_cpm_ercc <- cpm(molecules_filter[ercc_rows, ], log = TRUE)
write.table(molecules_cpm_ercc, "../data/molecules-bulk-cpm-ercc.txt", quote = FALSE,
            sep = "\t", col.names = NA)
```

## Session information

```{r info}
sessionInfo()
```
