---
title: "Compare read and molecule counts"
date: 2015-06-11
---

**Last updated:** `r Sys.Date()`

**Code version:** `r system("git log -1 --format='%H'", intern = TRUE)`

```{r chunk-options, include=FALSE}
source("chunk-options.R")
opts_chunk$set(cache = TRUE)
```

First, compared counts via three methods:

*  **reads_cpm** - standard counts per million
*  **molecules** - counts of molecules identified using UMIs
*  **molecules_per_lane** - counts of molecules identified using UMIs per each sequencing lane and then summed per sample

Then investigated the relationship between sequencing depth and total molecule count per sample.
Found that sequencing depth affects the total molecule count, which in turn affects PC1.
Will use TMM-normalize molecule counts per million mapped (cpm) for downstream analyses.

Therefore reran the original comparisons between reads and molecules, but this time using TMM-normalized counts per million for the molecules similar to the reads.
The correlation of the mean expression improved.

## Input

```{r packages, message=FALSE, cache=FALSE}
library("dplyr")
library("ggplot2")
theme_set(theme_bw(base_size = 16))
library("edgeR")
source("functions.R")
library("tidyr")
```

Input annotation.

```{r input-annotation}
anno <- read.table("../data/annotation.txt", header = TRUE,
                   stringsAsFactors = FALSE)
head(anno)
```

Input read counts.

```{r input-read-counts}
reads <- read.table("../data/reads.txt", header = TRUE,
                    stringsAsFactors = FALSE)
```

Input molecule counts.

```{r input-molecule-counts}
molecules <- read.table("../data/molecules.txt", header = TRUE,
                    stringsAsFactors = FALSE)
```

Input molecule counts summed across lanes.

```{r input-molecule-per-lane-counts}
molecules_per_lane <- read.table("../data/molecules-per-lane.txt", header = TRUE,
                    stringsAsFactors = FALSE)
```

Input list of quality single cells.

```{r input-quality-single-cells}
quality_single_cells <- scan("../data/quality-single-cells.txt",
                             what = "character")
```

## Filter

Keep only the single cells that passed the [QC filters](qc-cell-ipsc.html) and the bulk samples.

```{r}
reads <- reads[, grepl("bulk", colnames(reads)) |
                 colnames(reads) %in% quality_single_cells]
molecules <- molecules[, grepl("bulk", colnames(molecules)) |
                         colnames(molecules) %in% quality_single_cells]
molecules_per_lane <- molecules_per_lane[, grepl("bulk", colnames(molecules_per_lane)) |
                                           colnames(molecules_per_lane) %in% quality_single_cells]
anno <- anno[anno$well == "bulk" | anno$sample_id %in% quality_single_cells, ]
stopifnot(dim(reads) == dim(molecules),
          nrow(anno) == ncol(molecules_per_lane))
```

Remove genes with zero read or molecule counts in the single cell or bulk samples.

```{r remove-non-expressed-genes}
expressed <- rowSums(reads[anno$well == "bulk"]) > 0 &
             rowSums(reads[anno$well != "bulk"]) > 0 &
             rowSums(molecules[anno$well == "bulk"]) > 0 &
             rowSums(molecules[anno$well != "bulk"]) > 0
reads <- reads[expressed, ]
molecules <- molecules[expressed, ]
molecules_per_lane <- molecules_per_lane[expressed, ]
```

## Sequencing depth 
```{r seq-depth}
reads_per_molecule <- as.matrix(reads/molecules)
hist(reads_per_molecule, breaks=100)
plot(density(reads_per_molecule, na.rm = TRUE))
```


## Calculate counts per million (cpm)

Calculate cpm for the reads data using TMM-normalization.

```{r calc-cpm-reads}
norm_factors_reads <- calcNormFactors(reads, method = "TMM")
reads_cpm <- cpm(reads, lib.size = colSums(reads) * norm_factors_reads)
```

And for the molecules.

```{r calc-cpm-molecules}
norm_factors_mol <- calcNormFactors(molecules, method = "TMM")
molecules_cpm <- cpm(molecules, lib.size = colSums(molecules) * norm_factors_mol)
```

And for the molecules summed per lane.

```{r calc-cpm-molecules-per-lane}
norm_factors_mol_per_lane <- calcNormFactors(molecules_per_lane, method = "TMM")
molecules_per_lane_cpm <- cpm(molecules_per_lane,
                              lib.size = colSums(molecules_per_lane) *
                                         norm_factors_mol_per_lane)
```

## Compare reads and molecules

Compare the means of each gene obtained via the different methods.

```{r calc-means}
mean_data <- data.frame(reads_cpm = rowMeans(reads_cpm),
                        molecules = rowMeans(molecules),
                        molecules_per_lane = rowMeans(molecules_per_lane))
cor(mean_data)
```

All three are highly correlated.

```{r reads-v-molecules}
mean_data$type <- ifelse(grepl("ERCC", rownames(mean_data)), "ERCC", "gene")
ggplot(mean_data, aes(x = reads_cpm, y = molecules)) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_wrap(~ type)
```

There are only a few genes with molecule counts greater than the number of UMIs.

```{r over-umi-limit}
rownames(molecules)[rowMeans(molecules) > 1024]
```

They are highly expressed mitochondrial genes.

```{r reads-v-molecules-range-restricted, warning=FALSE}
ggplot(mean_data, aes(x = reads_cpm, y = molecules)) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_wrap(~ type) +
  ylim(0, 1100)
```


```{r reads-v-molecules-per-lane, warning=FALSE}
ggplot(mean_data, aes(x = reads_cpm, y = molecules_per_lane)) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_wrap(~ type)
```

The molecule counts and the molecule counts summed per sequencing lane are highly correlated.
This indicates that most of the bias is introduced in the library preparation step and not during sequencing.

```{r molecules-v-molecules-per-lane, warning=FALSE}
ggplot(mean_data, aes(x = molecules_per_lane, y = molecules)) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_wrap(~ type)
```

## Effect of sequencing depth on molecule count

How dependent are the molecule counts on the total molecule count for a given sample?
Should we standardize by the total molecule count per sample?
[Islam et al. 2014][Islam2014] argue that this is not necessary, "scales for molecule-counting scatterplots (Fig. 2d,e) are absolute and would not change appreciably if the number of reads were increased."
Let's check this assumption.

[Islam2014]: http://www.nature.com/nmeth/journal/v11/n2/full/nmeth.2772.html

Does the total number of molecules per sample vary with the total number of reads?
If it is not necessary to standardize the molecule counts, the molecule counts should be consistent across varying read depths.

```{r total-mol-v-reads-single}
total_counts_data <- data.frame(total_reads = colSums(reads) / 10^6,
                                total_molecules = colSums(molecules) / 10^3,
                                anno)
str(total_counts_data)
total_counts_single <- ggplot(total_counts_data[total_counts_data$well != "bulk", ],
                              aes(x = total_reads, y = total_molecules)) +
  geom_point(aes(col = as.factor(individual), shape = as.factor(batch))) +
  geom_smooth(method = "lm") +
  labs(x = "Total number of reads (x10^6)",
       y = "Total number of molecules (x10^3)",
       title = "Effect of read depth on single cells")
total_counts_single
```

```{r total-mol-v-reads-bulk}
total_counts_bulk <- total_counts_single %+%
  total_counts_data[total_counts_data$well == "bulk", ] +
  labs(x = "Total number of reads (x10^6)",
       y = "Total number of molecules (x10^3)",
       title = "Effect of read depth on bulk samples")
total_counts_bulk
```

So this is clearly not the case.
Perhaps in the ideal case where all the cells are sequenced to saturation, then any increasing sequencing would not make a difference in the molecule counts.

Also, there is a difference in total molecule count between the three individuals.

```{r total-molecules-by-ind}
total_molecules_ind <- ggplot(total_counts_data[total_counts_data$well != "bulk", ],
                              aes(x = as.factor(individual), y = total_molecules)) +
  geom_boxplot(aes(fill = as.factor(batch))) +
  scale_fill_brewer(type = "qual", palette = "Dark2", name ="Batch") +
  labs(x = "Individual",
       y = "Molecules (x10^3)",
       title = "Total molecule counts vary across individuals")
total_molecules_ind
```

But not for the total number of reads, as expected from the plot above of the effect of read depth where all three individuals span the x-axis of the total number of reads.

```{r total-reads-by-ind}
total_reads_ind <- total_molecules_ind %+% aes(y = total_reads) +
  labs(y = "Reads (x10^6)",
       title = "Total read counts vary across individuals")
total_reads_ind
```

What effect does this difference in total molecule count have in PCA?

```{r pca-single}
pca_single <- run_pca(molecules[, anno$well != "bulk"])
```

```{r pca-single-uncorrected}
plot_pca(pca_single$PCs, explained = pca_single$explained,
         metadata = anno[anno$well != "bulk", ], color = "individual",
         shape = "batch", factors = c("individual", "batch")) +
  labs(title = "PCA single cells uncorrected for depth")
```

```{r pc1-v-total-molecules-uncorrected}
pc1_v_total_mol_uncorrected <- ggplot(cbind(total_counts_data[total_counts_data$well != "bulk", ], pca_single$PCs),
       aes(x = total_molecules, y = PC1, col = as.factor(individual),
           shape = as.factor(batch))) +
  geom_point(alpha = 0.5) +
  labs(x = "Total number of molecules (x10^3)")
pc1_v_total_mol_uncorrected
```

```{r pc2-v-total-molecules-uncorrected}
pc2_v_total_mol_uncorrected <- pc1_v_total_mol_uncorrected %+% aes(y = PC2)
pc2_v_total_mol_uncorrected
```

The total molecule depth per sample is highly correlated with PC1.
However, it did not affect PC2, which captures the individual effect.

What happens to the PCA results when depth is properly accounted for using TMM-normalized counts per million?

```{r single-tmm-cpm}
norm_factors_mol_single <- calcNormFactors(molecules[, anno$well != "bulk"],
                                           method = "TMM")
molecules_cpm_single <- cpm(molecules[, anno$well != "bulk"],
                            lib.size = colSums(molecules[, anno$well != "bulk"]) *
                                       norm_factors_mol_single)
```

```{r pca-single-cpm}
pca_single_cpm <- run_pca(molecules_cpm_single)
```

```{r pca-single-corrected}
plot_pca(pca_single_cpm$PCs, explained = pca_single_cpm$explained,
         metadata = anno[anno$well != "bulk", ], color = "individual",
         shape = "batch", factors = c("individual", "batch")) +
  labs(title = "PCA single cells *corrected* for depth")
```

```{r pc1-v-total-molecules-corrected}
pc1_v_total_mol_corrected <- pc1_v_total_mol_uncorrected %+%
  cbind(total_counts_data[total_counts_data$well != "bulk", ], pca_single_cpm$PCs) +
  labs(title = "PCA single cells *corrected* for depth")
pc1_v_total_mol_corrected
```

```{r pc2-v-total-molecules-corrected}
pc2_v_total_mol_corrected <- pc1_v_total_mol_corrected %+% aes(y = PC2)
pc2_v_total_mol_corrected
```

PC1 is no longer associated with sequencing depth!

## Differences in conversion of reads to molecules

As seen above with the total counts, the conversion of reads to molecules varies between each of the 9 batches.
Below I fit a loess transformation to each individually.
It would be ideal if we could somehow we could correct for these differences and have them all follow a similar transformation from reads to molecules.

```{r gather-cols-to-rows}
convert_to_long <- function(r, m) {
  # Combines reads and molecules into long format for comparison of conversion
  #
  # r - reads in wide format
  # m - molecules in wide format
  r <- data.frame(gene = rownames(r), r)
  m <- data.frame(gene = rownames(m), m)
  r_long <- gather_(r, key = "id", value = "reads",
                    grep("NA", colnames(r), value = TRUE))
  m_long <- gather_(m, key = "id", value = "molecules",
                    grep("NA", colnames(m), value = TRUE))
  r_long <- separate_(r_long, col = "id",  sep = "\\.", remove = FALSE,
                     into = c("individual", "batch", "well"))
  stopifnot(r_long$id == m_long$id,
            r_long$gene == m_long$gene)
  conversion <- cbind(r_long, m_long$molecules)
  colnames(conversion)[ncol(conversion)] <- "molecules"
  stopifnot(nrow(conversion) == nrow(m_long))
  return(conversion)
}
```

In order to be able to make this plot, I have to subsample to fewer genes.
Otherwise it runs out of memory.

```{r subsample, cache=FALSE}
set.seed(12345)
num_subsampled <- 5000
sub_indices <- sample(1:nrow(reads), num_subsampled)
dim(reads)
reads_sub <- reads[sub_indices, ]
molecules_sub <- molecules[sub_indices, ]
reads_cpm_sub <- reads_cpm[sub_indices, ]
molecules_cpm_sub <- molecules_cpm[sub_indices, ]
conversion <- convert_to_long(reads_sub, molecules_sub)
conversion_cpm <- convert_to_long(reads_cpm_sub, molecules_cpm_sub)
head(conversion)
```

Summarize across the single cells for each of the 9 batches.

```{r summarize-conversion, cache=FALSE}
# counts
conversion_mean <- conversion %>%
  filter(well != "bulk") %>%
  group_by(individual, batch, gene) %>%
  summarize(reads_mean = mean(reads),
            reads_sem = sd(reads) / sqrt(length(reads)),
            molecules_mean = mean(molecules),
            molecules_sem = sd(molecules) / sqrt(length(molecules)))
# counts per million
conversion_cpm_mean <- conversion_cpm %>%
  filter(well != "bulk") %>%
  group_by(individual, batch, gene) %>%
  summarize(reads_mean = mean(reads),
            reads_sem = sd(reads) / sqrt(length(reads)),
            molecules_mean = mean(molecules),
            molecules_sem = sd(molecules) / sqrt(length(molecules)))
head(conversion_cpm_mean)
```

Compare the counts.

```{r convert-reads-molecules-per-batch, fig.width=9, fig.height=9, cache=FALSE}
conver_plot_counts <- ggplot(conversion_mean,
                             aes(x = reads_mean, y = molecules_mean, col = individual,
                                 shape = as.factor(batch))) +
  geom_point() +
  geom_errorbar(aes(ymin = molecules_mean - molecules_sem,
                    ymax = molecules_mean + molecules_sem)) +
  geom_errorbarh(aes(xmin = reads_mean - reads_sem,
                     xmax = reads_mean + reads_sem)) +
  geom_smooth(method = "loess", color = "black") +
  facet_grid(batch ~ individual) +
  # scale_x_log10() + scale_y_log10() +
  theme(legend.position = "none") +
  labs(x = "Reads per gene",
       y = "Molecules per gene",
       title = sprintf("Conversion per batch (subsample of %d genes)", num_subsampled))
conver_plot_counts
```

Compare the counts per million.

```{r convert-reads-molecules-per-batch-cpm, fig.width=9, fig.height=9, cache=FALSE}
conver_plot_cpm <- conver_plot_counts %+%
  conversion_cpm_mean +
  labs(x = "Reads per million per gene",
       y = "Molecules per million per gene",
       title = sprintf("Conversion per batch (subsample of %d genes) - cpm", num_subsampled))
conver_plot_cpm
```

Now visualizing only the ERCC.

```{r prepare-ercc, cache=FALSE}
conversion_ercc <- convert_to_long(reads[grep("ERCC", rownames(reads)), ],
                                   molecules[grep("ERCC", rownames(molecules)), ])
conversion_ercc_cpm <- convert_to_long(reads_cpm[grep("ERCC", rownames(reads_cpm)), ],
                                       molecules_cpm[grep("ERCC", rownames(molecules_cpm)), ])
# Remove 19098 batch 2 because the outlier throws off the axes
conversion_ercc <- conversion_ercc[!(conversion_ercc$individual == "NA19098" &
                                     conversion_ercc$batch == 2), ]
conversion_ercc_cpm <- conversion_ercc_cpm[!(conversion_ercc_cpm$individual == "NA19098" &
                                             conversion_ercc_cpm$batch == 2), ]
```

```{r summarize-conversion-ercc, cache=FALSE}
# counts
conversion_ercc_mean <- conversion_ercc %>%
  filter(well != "bulk") %>%
  group_by(individual, batch, gene) %>%
  summarize(reads_mean = mean(reads),
         reads_sem = sd(reads) / sqrt(length(reads)),
         molecules_mean = mean(molecules),
         molecules_sem = sd(molecules) / sqrt(length(molecules)))
# counts per million
conversion_ercc_cpm_mean <- conversion_ercc_cpm %>%
  filter(well != "bulk") %>%
  group_by(individual, batch, gene) %>%
  summarize(reads_mean = mean(reads),
         reads_sem = sd(reads) / sqrt(length(reads)),
         molecules_mean = mean(molecules),
         molecules_sem = sd(molecules) / sqrt(length(molecules)))
head(conversion_ercc_cpm_mean)
```

```{r check-ercc, cache=FALSE}
str(conversion_ercc)
table(conversion_ercc$individual, conversion_ercc$batch)
```

ERCC counts

```{r convert-reads-molecules-per-batch-ercc, fig.width=9, fig.height=9, cache=FALSE}
conver_plot_ercc <- conver_plot_counts %+%
  conversion_ercc_mean +
  labs(title = "Conversion per batch (ERCC genes)")
conver_plot_ercc
```

ERCC counts per million

```{r convert-reads-molecules-per-batch-ercc-cpm, fig.width=9, fig.height=9, cache=FALSE}
conver_plot_ercc_cpm <- conver_plot_counts %+%
  conversion_ercc_cpm_mean +
  labs(x = "Reads per million per gene",
       y = "Molecules per million per gene",
       title = "Conversion per batch (ERCC genes) - cpm")
conver_plot_ercc_cpm
```

## Compare reads and standardized molecules

This time standardize the molecule counts for the sequencing depth.

Compare the means of each gene obtained via the different methods.

```{r calc-means-std}
mean_data_std <- data.frame(reads_cpm = rowMeans(reads_cpm),
                        molecules_cpm = rowMeans(molecules_cpm),
                        molecules_per_lane_cpm = rowMeans(molecules_per_lane_cpm))
cor(mean_data_std)
```

All three are even more highly correlated now that the molecules are standardized.

```{r reads-v-molecules-std}
mean_data_std$type <- ifelse(grepl("ERCC", rownames(mean_data_std)), "ERCC", "gene")
ggplot(mean_data_std, aes(x = reads_cpm, y = molecules_cpm)) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_wrap(~ type)
```

Examining the lower range where most genes are:

```{r reads-v-molecules-range-restricted-std, warning=FALSE}
ggplot(mean_data_std, aes(x = reads_cpm, y = molecules_cpm)) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_wrap(~ type) +
  ylim(0, 10000)
```


```{r reads-v-molecules-per-lane-std, warning=FALSE}
ggplot(mean_data_std, aes(x = reads_cpm, y = molecules_per_lane_cpm)) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_wrap(~ type)
```

And as above, the molecule counts and the molecule counts summed per sequencing lane are highly correlated,
which indicates that most of the bias is introduced in the library preparation step and not during sequencing.

```{r molecules-v-molecules-per-lane-std, warning=FALSE}
ggplot(mean_data_std, aes(x = molecules_per_lane_cpm, y = molecules_cpm)) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_wrap(~ type)
```


## Session information

```{r info}
sessionInfo()
```
