---
title: "BASiCS"
date: 2015-08-10
---

**Last updated:** `r Sys.Date()`

**Code version:** `r system("git log -1 --format='%H'", intern = TRUE)`

```{r chunk-options, include=FALSE}
source("chunk-options.R")
```

This is run on my work laptop.

```{r packages}
library("BASiCS")
library("data.table")
source("functions.R")
library("ggplot2")
theme_set(theme_bw(base_size = 16))
```

##  Input

Below is the description of the data from the BASiCS vignette, interspersed with my code to load the data.

> The input dataset for BASiCS must contain the following 3 elements:

> * `Counts`: a matrix of raw expression counts with dimensions $q$ times $n$. First $q_0$ rows must correspond to biological genes. Last $q-q_0$ rows must correspond to technical spike-in genes.

Input annotation.

```{r input-annotation}
anno <- read.table("../data/annotation.txt", header = TRUE,
                   stringsAsFactors = FALSE)
```

Input molecule counts.

```{r input-molecule-counts}
molecules <- read.table("../data/molecules.txt", header = TRUE,
                    stringsAsFactors = FALSE)
```

Input list of quality single cells.

```{r input-quality-single-cells}
quality_single_cells <- scan("../data/quality-single-cells.txt",
                             what = "character")
```

Keep only the single cells that passed the [QC filters](qc-cell-ipsc.html).
This also removes the bulk samples.

```{r qc-filter}
molecules_single <- molecules[, colnames(molecules) %in% quality_single_cells]
anno_single <- anno[anno$sample_id %in% quality_single_cells, ]
stopifnot(ncol(molecules_single) == nrow(anno_single),
          colnames(molecules_single) == anno_single$sample_id)
```

Also remove batch 2 of individual 19098.

```{r remove-19098-batch-2-single}
molecules_single <- molecules_single[, !(anno_single$individual == 19098 & anno_single$batch == 2)]
anno_single <- anno_single[!(anno_single$individual == 19098 & anno_single$batch == 2), ]
stopifnot(ncol(molecules_single) == nrow(anno_single))
```

Remove genes with zero read counts in the single cells.

```{r remove-non-expressed-genes}
expressed_single <- rowSums(molecules_single) > 0
molecules_single <- molecules_single[expressed_single, ]
dim(molecules_single)
```

> * `Tech`: a vector of `TRUE`/`FALSE` elements with length $q$. If `Tech[i] = FALSE` the gene `i` is biological; otherwise the gene is spike-in.

```{r tech}
tech <- grepl("ERCC", rownames(molecules_single))
```

> * `SpikeInput`: a vector of length $q-q_0$ whose elements contain the input number of molecules for the spike-in genes (amount per cell).

```{r load-spike-input}
spike <- read.table("../data/expected-ercc-molecules.txt", header = TRUE,
                    sep = "\t", stringsAsFactors = FALSE)
```

Only keep the spike-ins that were observed in at least one cell.

```{r spike-input}
spike_input <- spike$ercc_molecules_well[spike$id %in% rownames(molecules_single)]
stopifnot(sum(tech) == length(spike_input))
```

`r length(spike_input)` of the ERCC spike-ins were observed in the single cell data.

> These elements must be stored into an object of class `BASiCS_Data`.

```{r create-object}
basics_data <- newBASiCS_Data(as.matrix(molecules_single), tech, spike_input)
```

## Filter

```{r filter}
basics_filter = BASiCS_Filter(as.matrix(molecules_single), tech, spike_input, 
                              MinTotalCountsPerCell = 2,
                              MinTotalCountsPerGene = 2, 
                              MinCellsWithExpression = 2,
                              MinAvCountsPerCellsWithExpression = 2)
filter_data = newBASiCS_Data(basics_filter$Counts, basics_filter$Tech,
                             basics_filter$SpikeInput)
```

## Fit the model

```{r fit-model}
if (file.exists("../data/chain_phi_mcmc.txt")) {
  chain_mu = as.matrix(fread("../data/chain_mu_mcmc.txt"))
  chain_delta = as.matrix(fread("../data/chain_delta_mcmc.txt"))
  chain_phi = as.matrix(fread("../data/chain_phi_mcmc.txt"))
  chain_s = as.matrix(fread("../data/chain_s_mcmc.txt"))
  chain_nu = as.matrix(fread("../data/chain_nu_mcmc.txt"))#
  chain_theta = as.matrix(fread("../data/chain_theta_mcmc.txt")[, 1, with = FALSE])

  mcmc_output <- newBASiCS_Chain(mu = chain_mu, delta = chain_delta,
                                 phi = chain_phi, s = chain_s,
                                 nu = chain_nu, theta = chain_theta)
} else {
  mcmc_output <- BASiCS_MCMC(filter_data, N = 4000, Thin = 10, Burn = 2000,
                             PrintProgress = TRUE, StoreChains = TRUE,
                             StoreDir = "../data", RunName = "mcmc")
}
```

Summarize the results.

```{r summary}
mcmc_summary <- Summary(mcmc_output)
```

## Cellular mRNA content

```{r phi-rna-content}
plot(mcmc_summary, Param = "phi")
```

## Capture efficiency

```{r s-capture-efficiency}
plot(mcmc_summary, Param = "s")
```

## Denoised data

Remove technical noise (i.e. normalize using the ERCC spike-ins).

```{r denoised-counts}
denoised = BASiCS_DenoisedCounts(Data = filter_data, Chain = mcmc_output)
```

```{r run-pca}
pca_basics <- run_pca(denoised)
```

```{r pca-basics}
plot_pca(pca_basics$PCs, explained = pca_basics$explained,
         metadata = anno_single, color = "individual",
         shape = "batch", factors = c("individual", "batch"))
```

## Session information

```{r info}
sessionInfo()
```
