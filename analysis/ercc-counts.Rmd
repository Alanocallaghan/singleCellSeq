---
title: "ERCC counts"
author: "PoYuan Tung"
date: 2015-07-07
---

**Last updated:** `r Sys.Date()`

**Code version:** `r system("git log -1 --format='%H'", intern = TRUE)`

```{r chunk-options, include=FALSE}
source("chunk-options.R")
library("edgeR")
library("ggplot2")
theme_set(theme_bw(base_size = 14))
```


## Input

Input annotation.

```{r input-annotation}
anno <- read.table("../data/annotation.txt", header = TRUE,
                   stringsAsFactors = FALSE)
head(anno)
```

Input ERCC concentration information.

```{r input-ercc}
ercc <- read.table("../data/ercc-info.txt", header = TRUE, sep = "\t",
                   stringsAsFactors = FALSE)
colnames(ercc) <- c("num", "id", "subgroup", "conc_mix1", "conc_mix2",
                    "expected_fc", "log2_mix1_mix2")
head(ercc)
stopifnot(nrow(ercc) == 92)
```

Input molecule counts.

```{r input-molecule-counts}
molecules <- read.table("../data/molecules.txt", header = TRUE,
                    stringsAsFactors = FALSE)
```

Input list of quality single cells.

```{r input-quality-single-cells}
quality_single_cells <- scan("../data/quality-single-cells.txt",
                             what = "character")
```

## Prepare single cell molecule data

Keep only the single cells that passed the [QC filters](qc-cell-ipsc.html).
This also removes the bulk samples.

```{r qc-filter}
molecules_single <- molecules[, colnames(molecules) %in% quality_single_cells]
anno_single <- anno[anno$sample_id %in% quality_single_cells, ]
stopifnot(ncol(molecules_single) == nrow(anno_single),
          colnames(molecules_single) == anno_single$sample_id)
```

Also remove batch 2 of individual 19098.

```{r remove-19098-batch-2-single}
molecules_single <- molecules_single[, !(anno_single$individual == 19098 & anno_single$batch == 2)]
anno_single <- anno_single[!(anno_single$individual == 19098 & anno_single$batch == 2), ]
stopifnot(ncol(molecules_single) == nrow(anno_single))
```

Remove genes with zero read counts in the single cells.

```{r remove-non-expressed-genes}
expressed_single <- rowSums(molecules_single) > 0
molecules_single <- molecules_single[expressed_single, ]
dim(molecules_single)
```

How many genes have greater than or equal to 1,024 molecules in at least one of the cells?

```{r over-expressed}
overexpressed_genes <- rownames(molecules_single)[apply(molecules_single, 1,
                                                        function(x) any(x >= 1024))]
```

`r length(overexpressed_genes)` have greater than or equal to 1,024 molecules.
Remove them.

```{r remove-over-expressed}
molecules_single <- molecules_single[!(rownames(molecules_single) %in% overexpressed_genes), ]
```

## Calculate the molecule counts of each ERCC in single cell

Accorindg to [Pollen et al.][Pollen2014], there are total 28,000 ERCC molecule per cell when the ERCC stock is used in 1:20,000 dilution. In our study, I used 1:50,000 dilution. Therefore, we have total 28000/2.5= 11200 ERCC molecule per cell.

[Pollen2014]: http://www.ncbi.nlm.nih.gov/pmc/articles/PMC4191988/

```{r ercc-number}
#### sort ercc file by gene ID
ercc <- ercc[order(ercc$id), ]

#### calculate the number of each ERCC based on the genes detected
ratio <- 11200/ sum(ercc[,"conc_mix1"])
ratio
ercc$counts <- ercc[,"conc_mix1"] * ratio
head(ercc)

#### try 28000 to see if integers were generated 
ratio_t <- 28000/ sum(ercc[,"conc_mix1"])
ercc$counts_t <- ercc[,"conc_mix1"] * ratio_t
head(ercc)
```

## Look at the correlation using the function that John created 
```{r correlation}
correlate_ercc <- function(observed, expected, description = "") {
  # Plots the relationship between the observed ERCC data and the expected ERCC
  # concentrations.

  # Args:
  #  observed: vector of summary statistic of observed ERCC counts
  #  expected: vector of ERCC concentrations
  #  description: optional string to add to title
  plot(expected, observed)
  ercc_fit <- lm(observed ~ expected)
  abline(ercc_fit, col = "red")
  title(sprintf("%s\nY ~ %.2fX + %.2f ; R-squared: %.2f", description,
                ercc_fit$coefficients[2], ercc_fit$coefficients[1],
                summary(ercc_fit)$r.squared))
}

#### number of ERCC detected in single cells
ercc_rows_molecules_single <- grep("ERCC", rownames(molecules_single))
length(ercc_rows_molecules_single)

#### keep only the detected ERCC in the ercc list
ercc_molecules_single <- ercc[ercc$id %in% rownames(molecules_single), ]
stopifnot(rownames(molecules_single[ercc_rows_molecules_single, ]) ==
          ercc_molecules_single$id)

#### what's the correlation of counts?
correlate_ercc(rowMeans(molecules_single[ercc_rows_molecules_single, ]), ercc_molecules_single$counts,
               description = "single cell molecules")
```

## The collision and the standardization 
### Correct for the collision probability.
First correct and look for the correlation. See [Grun et al. 2014][Grun2014] for details.

[Grun2014]: http://www.nature.com/nmeth/journal/v11/n6/full/nmeth.2930.html#methods

```{r collision-probability}
molecules_single_collision <- -1024 * log(1 - molecules_single / 1024)

correlate_ercc(rowMeans(molecules_single_collision[ercc_rows_molecules_single, ]), ercc_molecules_single$counts,
               description = "single cell molecules (after correction)")
```

### Standardize molecule numbers.
```{r calc-cpm-single}
molecules_single_cpm <- cpm(molecules_single_collision, log = TRUE)

correlate_ercc(rowMeans(molecules_single_cpm[ercc_rows_molecules_single, ]), log2(ercc_molecules_single$counts),
               description = "single cell log2 molecules per million")
```

## Capture efficiency

Invitrogen provides the concentration of each ERCC spike-in in attomoles per uL.

```{r ercc-conc-mix1}
summary(ercc$conc_mix1)
```

PoYuan diluted mix 1 1:2500.
Then she combined 1 uL of this 1:2500 diluted mix with 19 uL of other stuff to create 20 uL of lysis buffer.
She added 9 uL of lysis buffer to the C1 chip.
Each well received 13.5 uL of lysis buffer.

How many molecules do we expect each sample to contain?

```{r calculate-expected-molecules}
# Dilute 1:2500
ercc_conc_diluted <- ercc$conc_mix1 / 2500
# Dilute 1:20
ercc_conc_lysis <- ercc_conc_diluted / 20
ercc_molecules_lysis <- ercc_conc_lysis *
                        20 * # Number of uL of lysis buffer
                        1/10^18 * # Number of attomoles in a mole
                        6.02214179e23 # Number of molecules in a mole
# 9 uL added to chip
ercc_molecules_chip <- ercc_molecules_lysis * 9 / 20
summary(ercc_molecules_chip)
# 13.5 uL per well
ercc_molecules_well <- ercc_molecules_lysis * 13.5e-3 / 20
summary(ercc_molecules_well)
sum(ercc_molecules_well)
sum(ercc_molecules_well >= 1)
sum(ercc_molecules_well > 1024)
sum(ercc_molecules_well %% 2 == 0)
```

[Pollen et al.][Pollen2014] calculated that they had 28,000 molecules per sample.
Thus our estimate of `r sprintf("%.1f", sum(ercc_molecules_well))` seems reasonable, especially since we diluted our samples more.

```{r ercc-index}
ercc_index <- grep("ERCC", rownames(molecules_single))
length(ercc_index)
```

`r length(ercc_index)` of the ERCC spike-ins had at least one molecule observed in at least one of the `r ncol(molecules_single)` single cells.

The "capture efficiency" is defined differently across studies.
Some use it to report the number of wells that had exactly one viable cell out of the possible 96 on a C1 chip.
Others use it to report how many of the added ERCC spike-in molecules were successfully sequenced.
We are using the latter definition.
Thus after calculating the total number of expected ERCC molecules, I simply add up all the ERCC molecules observed for a given single cell and divide it by this total.

```{r capture-efficiency}
efficiency <- numeric(length = length(ercc_index))
total_ercc_molecules <- sum(ercc_molecules_well)
for (i in 1:ncol(molecules_single)) {
  efficiency[i] <- sum(molecules_single[ercc_index, i]) / total_ercc_molecules
}
summary(efficiency)
```

[Islam et al.][Islam2014] calculated efficiency using only those ERCC with molecule counts in the range of 1-504 (see Figure S6A).
I am assuming this filtering was done at the level of _expected_ molecule counts, since this would be consistent from cell to cell.

[Islam2014]: http://www.nature.com/nmeth/journal/v11/n2/full/nmeth.2772.html

```{r errc-index-islam}
ercc_islam <- ercc$id[ercc_molecules_well >= 1 & ercc_molecules_well <= 504]
ercc_molecules_well_islam <- ercc_molecules_well[ercc$id %in% ercc_islam]
ercc_index_islam <- which(rownames(molecules_single) %in% ercc_islam)
```

`r length(ercc_islam)` ERCC spike-ins are expected to have molecule counts in the range of 1-504.
Of these, `r length(ercc_index_islam)` were observed to have at least one molecule in at least one of the cells.

```{r capture-efficiency-islam}
efficiency_islam <- numeric(length = length(ercc_index_islam))
total_ercc_molecules_islam <- sum(ercc_molecules_well_islam)
for (i in 1:ncol(molecules_single)) {
  efficiency_islam[i] <- sum(molecules_single[ercc_index_islam, i]) / total_ercc_molecules_islam
}
summary(efficiency_islam)
```

Creating a visualization similar to [Figure 2I][Islam2014Fig2] in [Islam et al.][Islam2014].

[Islam2014Fig2]: http://www.nature.com/nmeth/journal/v11/n2/fig_tab/nmeth.2772_F2.html

```{r create-ercc-plot-data}
ercc_list <- list()
for (spike in ercc$id) {
  if (spike %in% rownames(molecules_single)) {
    ercc_list$id <- c(ercc_list$id, spike)
    ercc_list$observed_mean <- c(ercc_list$observed_mean,
                                 mean(as.numeric(molecules_single[spike, ])))
    ercc_list$observed_sem <- c(ercc_list$observed_sem,
                                 sd(as.numeric(molecules_single[spike, ])) /
                                 sqrt(ncol(molecules_single)))
    ercc_list$expected <- c(ercc_list$expected,
                            ercc_molecules_well[ercc$id == spike])
  }
}
ercc_plot <- as.data.frame(ercc_list, stringsAsFactors = FALSE)
str(ercc_plot)
```

```{r ercc-capture-efficiency, fig.width=8, fig.height=8}
p_efficiency <- ggplot(ercc_plot, aes(x = expected, y = observed_mean)) +
  geom_point() +
  geom_errorbar(aes(ymin = observed_mean - observed_sem,
                    ymax = observed_mean + observed_sem), width = 50) +
  labs(x = "Expected ERCC molecules",
       y = "Observed ERCC molecules\n(mean +/- sem)",
       title = "ERCC capture efficiency")
p_efficiency
```

Here is their result:

![Islam et al. Figure 2](http://www.nature.com/nmeth/journal/v11/n2/images/nmeth.2772-F2.jpg)

## Session information

```{r info}
sessionInfo()
```
