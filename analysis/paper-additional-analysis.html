<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />


<meta name="date" content="2016-06-23" />

<title>Additional analysis for the manuscript</title>

<script src="libs/jquery-1.11.0/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="libs/bootstrap-3.3.1/css/united.min.css" rel="stylesheet" />
<script src="libs/bootstrap-3.3.1/js/bootstrap.min.js"></script>
<script src="libs/bootstrap-3.3.1/shim/html5shiv.min.js"></script>
<script src="libs/bootstrap-3.3.1/shim/respond.min.js"></script>

<style type="text/css">

/* padding for bootstrap navbar */
body {
  padding-top: 50px;
  padding-bottom: 40px;
}


/* offset scroll position for anchor links (for fixed navbar)  */
.section h2 {
  padding-top: 55px;
  margin-top: -55px;
}
.section h3 {
  padding-top: 55px;
  margin-top: -55px;
}



/* don't use link color in navbar */
.dropdown-menu>li>a {
  color: black;
}

/* some padding for disqus */
#disqus_thread {
  margin-top: 45px;
}

</style>

<link rel="stylesheet" href="libs/font-awesome-4.1.0/css/font-awesome.min.css"/>

<style type="text/css">code{white-space: pre;}</style>
<link rel="stylesheet"
      href="libs/highlight/textmate.css"
      type="text/css" />
<script src="libs/highlight/highlight.js"></script>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>



</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img { 
  max-width:100%; 
  height: auto; 
}
</style>
<div class="container-fluid main-container">


<div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">singleCellSeq</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li><a href="index.html">Home</a></li>
        <li><a href="about.html">About</a></li>
        <li><a href="license.html">License</a></li>
        <li><a href="https://github.com/jdblischak/singleCellSeq">GitHub</a></li>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">
<h1 class="title">Additional analysis for the manuscript</h1>
<h4 class="date"><em>2016-06-23</em></h4>
</div>

<div id="TOC">
<ul>
<li><a href="#questions">Questions</a></li>
<li><a href="#input">Input</a></li>
<li><a href="#concentration-vs.total-molecule-count-ensg">Concentration vs. total molecule-count (ENSG)</a></li>
<li><a href="#reads-to-molecule-conversion-efficiency">Reads to molecule conversion efficiency</a></li>
<li><a href="#total-ensg-molecule-count-and-total-ercc-molecule-count">total ENSG molecule-count and total ERCC molecule-count</a></li>
<li><a href="#variance-components-per-gene">Variance components per gene</a></li>
<li><a href="#correlation-between-and-within-batches">Correlation between and within batches</a></li>
<li><a href="#session-information">Session information</a></li>
</ul>
</div>

<p><strong>Last updated:</strong> 2016-06-29</p>
<p><strong>Code version:</strong> c59e3a495e7257caa3180d1dfdaf315cdd79d715</p>
<pre class="r"><code>library(&quot;dplyr&quot;)
library(&quot;ggplot2&quot;)
library(&quot;cowplot&quot;)
library(&quot;lmtest&quot;)
library(&quot;lme4&quot;)
source(&quot;functions.R&quot;)</code></pre>
<div id="questions" class="section level2">
<h2>Questions</h2>
<ol style="list-style-type: decimal">
<li>Concentration vs. total molecule-count (ENSG)</li>
</ol>
<p>(Our study design allows us to investigate…)</p>
<p>total molecule-count ~ Concentration</p>
<p><a href="http://jdblischak.github.io/singleCellSeq/analysis/compare-reads-v-molecules-per-batch-test.html">previous work</a></p>
<ol start="2" style="list-style-type: decimal">
<li>Molecule-to-read conversion rate (ENSG, ERCC)</li>
</ol>
<p>(We explored…)</p>
<p>total molecule-count ~ read</p>
<ol start="3" style="list-style-type: decimal">
<li>total ERCC molecule-count and total ENSG molecule-count</li>
</ol>
<p>(Could we account…)</p>
<p>total ENSG molecule-count ~ total ERCC molecule-count</p>
<ol start="4" style="list-style-type: decimal">
<li>Percent variation explained by individual and replicate effect in ENSG and ERCC</li>
</ol>
<p>(As a first step…)</p>
<p><a href="http://jdblischak.github.io/singleCellSeq/analysis/compare-reads-v-molecules-per-batch-test.html">previous work</a></p>
</div>
<div id="input" class="section level2">
<h2>Input</h2>
<p>Input filtered annotation.</p>
<pre class="r"><code>anno_filter &lt;- read.table(&quot;../data/annotation-filter.txt&quot;, header = TRUE,
                   stringsAsFactors = FALSE)
head(anno_filter)</code></pre>
<pre><code>  individual replicate well      batch      sample_id
1    NA19098        r1  A01 NA19098.r1 NA19098.r1.A01
2    NA19098        r1  A02 NA19098.r1 NA19098.r1.A02
3    NA19098        r1  A04 NA19098.r1 NA19098.r1.A04
4    NA19098        r1  A05 NA19098.r1 NA19098.r1.A05
5    NA19098        r1  A06 NA19098.r1 NA19098.r1.A06
6    NA19098        r1  A07 NA19098.r1 NA19098.r1.A07</code></pre>
<p>Input filtered molecule counts.</p>
<pre class="r"><code>molecules_filter &lt;- read.table(&quot;../data/molecules-filter.txt&quot;, header = TRUE,
                               stringsAsFactors = FALSE)
molecules_filter_ENSG &lt;- molecules_filter[grep(&quot;ERCC&quot;, rownames(molecules_filter), invert = TRUE), ]
  
molecules_filter_ERCC &lt;- molecules_filter[grep(&quot;ERCC&quot;, rownames(molecules_filter), invert = FALSE), ]

stopifnot(ncol(molecules_filter) == nrow(anno_filter),
          colnames(molecules_filter) == anno_filter$sample_id)</code></pre>
<p>Input filtered read counts</p>
<pre class="r"><code>reads_filter &lt;- read.table(&quot;../data/reads-filter.txt&quot;, header = TRUE,
                    stringsAsFactors = FALSE)
reads_filter_ENSG &lt;- reads_filter[grep(&quot;ERCC&quot;, rownames(reads_filter), invert = TRUE), ]

stopifnot(all.equal(colnames(reads_filter_ENSG), 
                    colnames(molecules_filter_ENSG)))</code></pre>
<p>Input quality control file. Filter cells to match cells in molecules_filter.</p>
<pre class="r"><code>qc &lt;- read.table(&quot;../data/qc-ipsc.txt&quot;, header = TRUE,
                 stringsAsFactors = FALSE)
qc$sample_id &lt;- with(qc, paste0(individual, &quot;.&quot;, replicate, &quot;.&quot;, well))

qc_filter &lt;- qc[match(anno_filter$sample_id, qc$sample_id), ]

stopifnot(all.equal(qc_filter$sample_id, anno_filter$sample_id))</code></pre>
<p>Input standardized molecule counts.</p>
<pre class="r"><code>molecules_cpm &lt;- read.table(&quot;../data/molecules-cpm.txt&quot;, header = TRUE,
                            stringsAsFactors = FALSE)
stopifnot(ncol(molecules_cpm) == nrow(anno_filter),
          colnames(molecules_cpm) == anno_filter$sample_id)</code></pre>
<p>Input Poisson GLM transformed molecule counts per million.</p>
<pre class="r"><code>molecules_cpm_trans &lt;- read.table(&quot;../data/molecules-cpm-trans.txt&quot;, header = TRUE,
                               stringsAsFactors = FALSE)
stopifnot(ncol(molecules_cpm_trans) == nrow(anno_filter),
          colnames(molecules_cpm_trans) == anno_filter$sample_id)</code></pre>
<p>Input final batch-corrected molecule counts per million.</p>
<pre class="r"><code>molecules_final &lt;- read.table(&quot;../data/molecules-final.txt&quot;, header = TRUE,
                              stringsAsFactors = FALSE)
stopifnot(ncol(molecules_final) == nrow(anno_filter),
          colnames(molecules_final) == anno_filter$sample_id)</code></pre>
</div>
<div id="concentration-vs.total-molecule-count-ensg" class="section level2">
<h2>Concentration vs. total molecule-count (ENSG)</h2>
<p>As we try to understand the general relationships between sequencing results and cellular mRNA content, we remove outlier batches. NA19098 replicate 1 failed the quantification of the concentration of the single cells and was hence removed. Because NA19098 concentration is only quantified in one replicate, we removed NA19098 from analysis involving batch differences and concentration.</p>
<pre class="r"><code>anno_single &lt;- anno_filter
ercc_index &lt;- grepl(&quot;ERCC&quot;, rownames(molecules_filter))
anno_single$total_molecules_gene = colSums(molecules_filter[!ercc_index, ])
anno_single$total_molecules_ercc = colSums(molecules_filter[ercc_index, ])
anno_single$total_molecules = colSums(molecules_filter)
anno_single$num_genes = apply(molecules_filter[!ercc_index, ], 2, function(x) sum(x &gt; 0))
anno_single$concentration &lt;- qc_filter$concentration[match(anno_single$sample_id, qc_filter$sample_id)]

anno_single &lt;- anno_single %&gt;% filter(individual != &quot;NA19098&quot;)
anno_single$individual &lt;- as.factor(anno_single$individual)
anno_single$replicate &lt;- as.factor(anno_single$replicate)</code></pre>
<p>Correlation between total molecule-count and concentration.</p>
<pre class="r"><code>with(anno_single, 
     cor.test(total_molecules_gene /(10^3), concentration, 
              method = &quot;spearman&quot;))</code></pre>
<pre><code>Warning in cor.test.default(total_molecules_gene/(10^3), concentration, :
Cannot compute exact p-value with ties</code></pre>
<pre><code>
    Spearman&#39;s rank correlation rho

data:  total_molecules_gene/(10^3) and concentration
S = 7385800, p-value &lt; 2.2e-16
alternative hypothesis: true rho is not equal to 0
sample estimates:
      rho 
0.4103248 </code></pre>
<pre class="r"><code>with(anno_single[anno_single$individual == &quot;NA19101&quot;,], 
     cor.test(total_molecules_gene /(10^3), concentration, 
              method = &quot;spearman&quot;))</code></pre>
<pre><code>Warning in cor.test.default(total_molecules_gene/(10^3), concentration, :
Cannot compute exact p-value with ties</code></pre>
<pre><code>
    Spearman&#39;s rank correlation rho

data:  total_molecules_gene/(10^3) and concentration
S = 912310, p-value = 2.342e-06
alternative hypothesis: true rho is not equal to 0
sample estimates:
      rho 
0.3259157 </code></pre>
<pre class="r"><code>with(anno_single[anno_single$individual == &quot;NA19239&quot;,], 
     cor.test(total_molecules_gene /(10^3), concentration, 
              method = &quot;spearman&quot;))</code></pre>
<pre><code>Warning in cor.test.default(total_molecules_gene/(10^3), concentration, :
Cannot compute exact p-value with ties</code></pre>
<pre><code>
    Spearman&#39;s rank correlation rho

data:  total_molecules_gene/(10^3) and concentration
S = 903010, p-value = 2.964e-15
alternative hypothesis: true rho is not equal to 0
sample estimates:
      rho 
0.4980306 </code></pre>
<pre class="r"><code># per replicate
sapply(unique(anno_single$batch), function(batch) {
with(anno_single[anno_single$batch == batch,], 
     cor(total_molecules_gene /(10^3), concentration, 
              method = &quot;spearman&quot;))
})</code></pre>
<pre><code> NA19101.r1  NA19101.r2  NA19101.r3  NA19239.r1  NA19239.r2  NA19239.r3 
 0.36385586  0.52144169 -0.01728507  0.77089967  0.77088980 -0.04157741 </code></pre>
<p>We take total molecule-count divided by 1000.</p>
<pre class="r"><code>fit &lt;- lmer(total_molecules_gene /(10^3)~ concentration + individual + 
                (1|individual:replicate),
              data = anno_single)
summary(fit)</code></pre>
<pre><code>Linear mixed model fit by REML [&#39;lmerMod&#39;]
Formula: total_molecules_gene/(10^3) ~ concentration + individual + (1 |  
    individual:replicate)
   Data: anno_single

REML criterion at convergence: 3263.5

Scaled residuals: 
    Min      1Q  Median      3Q     Max 
-2.4154 -0.7006 -0.1026  0.6488  3.9472 

Random effects:
 Groups               Name        Variance Std.Dev.
 individual:replicate (Intercept)   8.8     2.967  
 Residual                         134.2    11.583  
Number of obs: 422, groups:  individual:replicate, 6

Fixed effects:
                  Estimate Std. Error t value
(Intercept)         35.419      3.278  10.805
concentration       12.860      1.468   8.762
individualNA19239    7.680      2.677   2.869

Correlation of Fixed Effects:
            (Intr) cncntr
concentratn -0.814       
indvNA19239 -0.392 -0.025</code></pre>
<pre class="r"><code>fit_1 &lt;- lm(total_molecules_gene /(10^3) ~ concentration + individual, 
            data = anno_single)
fit_2 &lt;- lmer(total_molecules_gene /(10^3) ~ concentration +
                (1|individual:replicate), data = anno_single)

# significance of individual effect
lrtest(fit_2, fit)</code></pre>
<pre><code>Likelihood ratio test

Model 1: total_molecules_gene/(10^3) ~ concentration + (1 | individual:replicate)
Model 2: total_molecules_gene/(10^3) ~ concentration + individual + (1 | 
    individual:replicate)
  #Df  LogLik Df  Chisq Pr(&gt;Chisq)   
1   4 -1636.4                        
2   5 -1631.7  1 9.2709   0.002328 **
---
Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<pre class="r"><code># significance of replicate effect
anova(fit, fit_1)</code></pre>
<pre><code>refitting model(s) with ML (instead of REML)</code></pre>
<pre><code>Data: anno_single
Models:
fit_1: total_molecules_gene/(10^3) ~ concentration + individual
fit: total_molecules_gene/(10^3) ~ concentration + individual + (1 | 
fit:     individual:replicate)
      Df    AIC    BIC  logLik deviance  Chisq Chi Df Pr(&gt;Chisq)   
fit_1  4 3288.1 3304.3 -1640.1   3280.1                            
fit    5 3281.8 3302.1 -1635.9   3271.8 8.2633      1   0.004045 **
---
Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
</div>
<div id="reads-to-molecule-conversion-efficiency" class="section level2">
<h2>Reads to molecule conversion efficiency</h2>
<p>Prepare ERCC data</p>
<pre class="r"><code>reads_ERCC &lt;- reads_filter[grep(&quot;ERCC&quot;, rownames(reads_filter), 
                                invert = FALSE), ]
molecules_ERCC &lt;- molecules_filter[grep(&quot;ERCC&quot;, rownames(molecules_filter), 
                                invert = FALSE), ]

total_counts_ERCC &lt;- data.frame(total_reads = colSums(reads_ERCC),
                                total_molecules = colSums(molecules_ERCC))
total_counts_ERCC$conversion &lt;- with(total_counts_ERCC,
                                     total_molecules/total_reads)
total_counts_ERCC$individual &lt;- as.factor(anno_filter$individual[match(rownames(total_counts_ERCC),
                          anno_filter$sample_id)])
total_counts_ERCC$replicate &lt;- as.factor(anno_filter$replicate[match(rownames(total_counts_ERCC),
                          anno_filter$sample_id)])</code></pre>
<p>Prepare ENSG data</p>
<pre class="r"><code>reads_ENSG &lt;- reads_filter[grep(&quot;ERCC&quot;, rownames(reads_filter), 
                                invert = TRUE), ]
molecules_ENSG &lt;- molecules_filter[grep(&quot;ERCC&quot;, rownames(molecules_filter), 
                                invert = TRUE), ]

total_counts_ENSG &lt;- data.frame(total_reads = colSums(reads_ENSG),
                                total_molecules = colSums(molecules_ENSG))
total_counts_ENSG$conversion &lt;- with(total_counts_ENSG,
                                     total_molecules/total_reads)
total_counts_ENSG$individual &lt;- as.factor(anno_filter$individual[match(rownames(total_counts_ENSG),
                          anno_filter$sample_id)])
total_counts_ENSG$replicate &lt;- as.factor(anno_filter$replicate[match(rownames(total_counts_ENSG),
                          anno_filter$sample_id)])</code></pre>
<p>Concentration distribution is skewed for both ERCC and ENSG genes. Hence, we analyze the log2 conversion data (log2 base was taken so that our log transformation base is consistent throughout the paper).</p>
<pre class="r"><code>par(mfrow = c(2,2))
hist(total_counts_ERCC$conversion,
     main = &quot;ERCC spike-in&quot;,
     xlab = &quot;Conversion&quot;)
hist(log2(total_counts_ERCC$conversion),
     main = &quot;ERCC spike-in&quot;,
     xlab = &quot;log2 Conversion&quot;)
hist(total_counts_ENSG$conversion,
     main = &quot;Endogenous genes&quot;,
     xlab = &quot;Conversion&quot;)
hist(log2(total_counts_ENSG$conversion),
     main = &quot;Endogenous genes&quot;,
     xlab = &quot;log2 Conversion&quot;)</code></pre>
<p><img src="figure/paper-additional-analysis.Rmd/unnamed-chunk-7-1.png" title="" alt="" width="768" style="display: block; margin: auto;" /></p>
<p>ERCC Model fitting</p>
<pre class="r"><code>fit &lt;- lmer(log2(conversion) ~ individual + 
              (1|individual:replicate), 
            data = total_counts_ERCC)
fit_1 &lt;- lm(log2(conversion) ~ individual,
            data = total_counts_ERCC)
fit_2 &lt;- lmer(log2(conversion) ~ 1 + 
              (1|individual:replicate), 
            data = total_counts_ERCC)

# significance of individual effect
lrtest(fit_2, fit)</code></pre>
<pre><code>Likelihood ratio test

Model 1: log2(conversion) ~ 1 + (1 | individual:replicate)
Model 2: log2(conversion) ~ individual + (1 | individual:replicate)
  #Df  LogLik Df  Chisq Pr(&gt;Chisq)   
1   3 -217.72                        
2   5 -212.09  2 11.263   0.003584 **
---
Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<pre class="r"><code># significance of replicate effect
anova(fit, fit_1)</code></pre>
<pre><code>refitting model(s) with ML (instead of REML)</code></pre>
<pre><code>Data: total_counts_ERCC
Models:
fit_1: log2(conversion) ~ individual
fit: log2(conversion) ~ individual + (1 | individual:replicate)
      Df    AIC    BIC  logLik deviance Chisq Chi Df Pr(&gt;Chisq)  
fit_1  4 425.46 442.80 -208.73   417.46                          
fit    5 421.41 443.08 -205.70   411.41 6.052      1    0.01389 *
---
Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<p>ENSG Model fitting</p>
<pre class="r"><code>fit &lt;- lmer(log2(conversion) ~ individual + 
              (1|individual:replicate), 
            data = total_counts_ENSG)
fit_1 &lt;- lm(log2(conversion) ~ individual,
            data = total_counts_ENSG)
fit_2 &lt;- lmer(log2(conversion) ~ 1 + 
              (1|individual:replicate), 
            data = total_counts_ENSG)

# significance of individual effect
lrtest(fit_2, fit)</code></pre>
<pre><code>Likelihood ratio test

Model 1: log2(conversion) ~ 1 + (1 | individual:replicate)
Model 2: log2(conversion) ~ individual + (1 | individual:replicate)
  #Df LogLik Df  Chisq Pr(&gt;Chisq)   
1   3 127.45                        
2   5 132.70  2 10.508   0.005226 **
---
Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<pre class="r"><code># significance of replicate effect
anova(fit, fit_1)</code></pre>
<pre><code>refitting model(s) with ML (instead of REML)</code></pre>
<pre><code>Data: total_counts_ENSG
Models:
fit_1: log2(conversion) ~ individual
fit: log2(conversion) ~ individual + (1 | individual:replicate)
      Df     AIC     BIC logLik deviance  Chisq Chi Df Pr(&gt;Chisq)    
fit_1  4 -231.46 -214.12 119.73  -239.46                             
fit    5 -268.48 -246.81 139.24  -278.48 39.026      1  4.182e-10 ***
---
Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
</div>
<div id="total-ensg-molecule-count-and-total-ercc-molecule-count" class="section level2">
<h2>total ENSG molecule-count and total ERCC molecule-count</h2>
<p>Prepare data</p>
<pre class="r"><code>anno_temp &lt;- anno_filter

anno_temp$ensg_total_count &lt;- 
  colSums(molecules_filter[grep(&quot;ERCC&quot;, 
                           rownames(molecules_filter), invert = FALSE), ])
anno_temp$ercc_total_count &lt;- 
  colSums(molecules_filter[grep(&quot;ERCC&quot;, 
                           rownames(molecules_filter), invert = TRUE), ])</code></pre>
<p>Check if total count ERCC is normal distribution</p>
<pre class="r"><code>par(mfrow = c(2,2))
hist(anno_temp$ercc_total_count,
     main = &quot;ERCC spike-in&quot;,
     xlab = &quot;Total counts&quot;)
hist(log2(anno_temp$ercc_total_count),
     main = &quot;ERCC spike-in&quot;,
     xlab = &quot;log2 Total counts&quot;)
hist(anno_temp$ensg_total_count,
     main = &quot;Endogenous genes&quot;,
     xlab = &quot;Total counts&quot;)
hist(log2(anno_temp$ensg_total_count),
     main = &quot;Endogenous genes&quot;,
     xlab = &quot;log2 Total counts&quot;)</code></pre>
<p><img src="figure/paper-additional-analysis.Rmd/unnamed-chunk-11-1.png" title="" alt="" width="768" style="display: block; margin: auto;" /></p>
<p>First, we assess total ERCC molecule-count beteween individuals and replicates.</p>
<pre class="r"><code>fit &lt;- lmer(log2(ercc_total_count) ~ individual + 
              (1|individual:replicate), 
            data = anno_temp)
fit_1 &lt;- lm(log2(ercc_total_count) ~ individual,
            data = anno_temp)
fit_2 &lt;- lmer(log2(ercc_total_count) ~ 1 + 
              (1|individual:replicate), 
            data = anno_temp)

# significance of individual effect
lrtest(fit_2, fit)</code></pre>
<pre><code>Likelihood ratio test

Model 1: log2(ercc_total_count) ~ 1 + (1 | individual:replicate)
Model 2: log2(ercc_total_count) ~ individual + (1 | individual:replicate)
  #Df  LogLik Df  Chisq Pr(&gt;Chisq)  
1   3 -138.78                       
2   5 -136.23  2 5.1014    0.07803 .
---
Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<pre class="r"><code># significance of replicate effect
anova(fit, fit_1)</code></pre>
<pre><code>refitting model(s) with ML (instead of REML)</code></pre>
<pre><code>Data: anno_temp
Models:
fit_1: log2(ercc_total_count) ~ individual
fit: log2(ercc_total_count) ~ individual + (1 | individual:replicate)
      Df    AIC    BIC  logLik deviance  Chisq Chi Df Pr(&gt;Chisq)    
fit_1  4 281.21 298.55 -136.60   273.21                             
fit    5 270.03 291.70 -130.01   260.03 13.181      1  0.0002828 ***
---
Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<p>Second, we perform the same analysis on total ENSG molecule-counts.</p>
<pre class="r"><code>fit &lt;- lmer(log2(ensg_total_count) ~ individual + 
              (1|individual:replicate), 
            data = anno_temp)
fit_1 &lt;- lm(log2(ensg_total_count) ~ individual,
            data = anno_temp)
fit_2 &lt;- lmer(log2(ensg_total_count) ~ 1 + 
              (1|individual:replicate), 
            data = anno_temp)

# significance of individual effect
lrtest(fit_2, fit)</code></pre>
<pre><code>Likelihood ratio test

Model 1: log2(ensg_total_count) ~ 1 + (1 | individual:replicate)
Model 2: log2(ensg_total_count) ~ individual + (1 | individual:replicate)
  #Df LogLik Df  Chisq Pr(&gt;Chisq)
1   3 254.98                     
2   5 256.73  2 3.5097     0.1729</code></pre>
<pre class="r"><code># significance of replicate effect
anova(fit, fit_1)</code></pre>
<pre><code>refitting model(s) with ML (instead of REML)</code></pre>
<pre><code>Data: anno_temp
Models:
fit_1: log2(ensg_total_count) ~ individual
fit: log2(ensg_total_count) ~ individual + (1 | individual:replicate)
      Df     AIC     BIC  logLik deviance  Chisq Chi Df Pr(&gt;Chisq)    
fit_1  4  -86.97  -69.63  47.485   -94.97                             
fit    5 -510.93 -489.25 260.463  -520.93 425.96      1  &lt; 2.2e-16 ***
---
Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<p>Second, we include total ENSG molecule-count in the model of total ERCC molecule-count in addition to individual and replicate factors.</p>
<p>ERCC ~ ENSG</p>
<pre class="r"><code>fit &lt;- lmer(log2(ercc_total_count) ~ log2(ensg_total_count) + individual + 
              (1|individual:replicate), 
            data = anno_temp)
fit_1 &lt;- lm(log2(ercc_total_count) ~ log2(ensg_total_count) + individual,
            data = anno_temp)
fit_2 &lt;- lmer(log2(ercc_total_count) ~ log2(ensg_total_count) + 
              (1|individual:replicate), 
            data = anno_temp)

# significance of individual effect
lrtest(fit_2, fit)</code></pre>
<pre><code>Likelihood ratio test

Model 1: log2(ercc_total_count) ~ log2(ensg_total_count) + (1 | individual:replicate)
Model 2: log2(ercc_total_count) ~ log2(ensg_total_count) + individual + 
    (1 | individual:replicate)
  #Df  LogLik Df  Chisq Pr(&gt;Chisq)
1   4 -66.621                     
2   6 -66.770  2 0.2977     0.8617</code></pre>
<pre class="r"><code># significance of replicate effect
anova(fit, fit_1)</code></pre>
<pre><code>refitting model(s) with ML (instead of REML)</code></pre>
<pre><code>Data: anno_temp
Models:
fit_1: log2(ercc_total_count) ~ log2(ensg_total_count) + individual
fit: log2(ercc_total_count) ~ log2(ensg_total_count) + individual + 
fit:     (1 | individual:replicate)
      Df    AIC    BIC  logLik deviance  Chisq Chi Df Pr(&gt;Chisq)    
fit_1  5 224.79 246.46 -107.39   214.79                             
fit    6 134.98 160.99  -61.49   122.98 91.806      1  &lt; 2.2e-16 ***
---
Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
</div>
<div id="variance-components-per-gene" class="section level2">
<h2>Variance components per gene</h2>
<p>Load model fitting code - a wrapper of the blmer function that fits a bayesian nested model for one gene at a time.</p>
<pre class="r"><code>#&#39; Per gene variance component model
#&#39;
#&#39; @param xx Matrix of expression measurements on log scale.
#&#39; @param annotation Meta-data matrix of each column of xx.

gene_variation &lt;- function(counts, annotation) {
  
  individual &lt;- as.factor(annotation$individual)
  replicate &lt;- as.factor(annotation$replicate)
  
  ## fit bayesian GLM one gene at a time
  
  blme_fit &lt;- lapply( 1:NROW(counts), function(i) {
      
      value &lt;- unlist(counts[i,])
      
      fit_try &lt;- tryCatch( 
        fit &lt;- blme::blmer(value ~ 1|individual/replicate, 
                           cov.prior = gamma(shape = 2),
                           resid.prior = gamma(shape = 2)),
                             condition = function(c) c)
      if(inherits(fit_try, &quot;condition&quot;)){
      var_foo &lt;- rep(NA, 3)
      return(var_foo)
      }
      if(!inherits(fit_try, &quot;condition&quot;)){
        var_foo &lt;- as.data.frame(VarCorr(fit_try))[,4]
        var_foo &lt;- var_foo[c(2,1,3)]
        var_foo
      }
    })
  blme_fit &lt;- do.call(rbind, blme_fit)
  rownames(blme_fit) &lt;- rownames(counts)
  colnames(blme_fit) &lt;- c(&quot;individual&quot;,&quot;replicate&quot;,&quot;residual&quot;)
  blme_fit
}</code></pre>
<pre class="r"><code>individual &lt;- as.factor(anno_filter$individual)
replicate &lt;- as.factor(anno_filter$replicate)

## endogenous molecule-count
blme_raw &lt;- gene_variation(counts = log2(molecules_filter_ENSG+1),
                           annotation = anno_filter)

## ERCC molecule-count
blme_ercc &lt;- gene_variation(counts = log2(molecules_filter_ERCC+1),
                            annotation = anno_filter)

## ENSG CPM
blme_cpm &lt;- gene_variation(counts = molecules_cpm, 
                           annotation = anno_filter)

## ENSG CPM Poisson
blme_cpm_trans &lt;- gene_variation(counts = molecules_cpm_trans, 
                           annotation = anno_filter)

## ENSG CPM Poisson
blme_final &lt;- gene_variation(counts = molecules_final, 
                           annotation = anno_filter)

save(blme_raw, blme_ercc, blme_cpm, blme_cpm_trans,
     blme_final,
     file = &quot;../data/blme-variance.rda&quot;)</code></pre>
<p>Compute proportion of variance explained: the above analysis produces variance component estimates (e.g., <span class="math">\(\sigma^2_b\)</span> for batch effect) that are based on a penalized maximum likelihood approach. We compute naive approximation of sum of squared variation for the individual effect and for the batch effect, and their proportions of variation. Specifically, to simplify the computations of degrees of freedom for each factor, we approximate a balanced nested design and compute estiamted number of levels of each factor as the average of the observed number of levels of each factor: the approximate number of batches is 2.67 (i.e., (2+3+3)/3) and and the approximate number of cell is 70.5 (i.e., average number of cell samples per batch).</p>
<pre class="r"><code>load(&quot;../data/blme-variance.rda&quot;)

labels &lt;- c(&quot;Endogenous raw&quot;, &quot;ERCC raw&quot;,
            &quot;Endogenous CPM&quot;, &quot;Endogenous Poisson&quot;,
            &quot;Endogenous final&quot;)
blme_list &lt;- list(blme_raw, blme_ercc, blme_cpm, 
                  blme_cpm_trans, blme_final)
prop_list &lt;- vector(&quot;list&quot;, length(blme_list))
names(prop_list) &lt;- c(&quot;raw&quot;, &quot;ercc&quot;, &quot;cpm&quot;, &quot;cpm_trans&quot;, &quot;final&quot;)
par(mfrow = c(2,3))
for (i in c(1:length(blme_list))) {
  res &lt;- blme_list[[i]]  
  ms_ind &lt;- (res[,1]*2.67*70.5) + (res[,2]*70.5) + res[,3]
  ms_batch &lt;- (res[,2]*70.5) + res[,3]
  ms_resid &lt;- res[,3]
  ss_ind &lt;- ms_ind*(3-1)
  ss_batch &lt;- ms_batch*3*(2.67-1)
  ss_resid &lt;- ms_resid*3*2.67*(70.5-1)
  prop_ind &lt;- ss_ind/(ss_ind + ss_batch + ss_resid)
  prop_batch &lt;- ss_batch/(ss_ind + ss_batch + ss_resid)
  prop_list[[i]] &lt;- data.frame(prop_ind = prop_ind,
                               prop_batch = prop_batch)
  plot(prop_ind, prop_batch,
       xlab = paste(&quot;Individual&quot;, 
                    100*round(median(prop_ind, na.rm = TRUE), 2), &quot;%&quot;),
       ylab = paste(&quot;Batch&quot;, 
                    100*round(median(prop_batch, na.rm = TRUE), 2), &quot;%&quot;),
       main = labels[i])
  abline(0, 1, col = &quot;red&quot;)
}
title(main = &quot;Proportion of individual-level variance&quot;,
      outer = TRUE, line = -1)</code></pre>
<p><img src="figure/paper-additional-analysis.Rmd/unnamed-chunk-16-1.png" title="" alt="" width="768" style="display: block; margin: auto;" /></p>
<p>Boxplot displaying proportion of variance explained due to individual, batch and residual cell-to-cell variation.</p>
<pre class="r"><code>load(&quot;../data/blme-variance.rda&quot;)
theme_set(theme_bw(base_size = 12))
theme_update(panel.grid.minor.x = element_blank(),
             panel.grid.minor.y = element_blank(),
             panel.grid.major.x = element_blank(),
             panel.grid.major.y = element_blank())
cowplot::plot_grid(
  ggplot(
    data.frame(proportion = 
                 c(prop_list$raw$prop_ind, 
                   prop_list$raw$prop_batch, 
                   1- prop_list$raw$prop_ind - prop_list$raw$prop_batch),
              type = rep(1:3, 
                         each = dim(prop_list$raw)[1])),
          aes(x = factor(type,
                          labels = c(&quot;Individual&quot;,
                                     &quot;C1 replicate&quot;,
                                     &quot;Residual \n cell-to-cell variance&quot;)), 
              y = proportion)) +
    geom_violin(alpha = .5) +
    geom_boxplot(alpha = .01, width = 0.1, 
                 position = position_dodge(width = 0.9)) + 
    ylim(0,1) + xlab(&quot;&quot;) + ylab(&quot;Proportion of variance explained&quot;) +
    labs( title = &quot;The proportion of variance due to individual is larger than \n variance due to C1 batch in endogenous genes&quot;),
  ggplot(
    data.frame(proportion = 
                 c(prop_list$ercc$prop_ind, 
                   prop_list$ercc$prop_batch, 
                   1- prop_list$ercc$prop_ind - prop_list$ercc$prop_batch),
              type = rep(1:3, 
                         each = dim(prop_list$ercc)[1])),
          aes(x = factor(type,
                          labels = c(&quot;Individual&quot;,
                                     &quot;C1 replicate&quot;,
                                     &quot;Residual \n cell-to-cell variance&quot;)), 
              y = proportion)) +
    geom_violin(alpha = .5) +
    geom_boxplot(alpha = .01, width = 0.1, 
                 position = position_dodge(width = 0.9)) + 
    ylim(0,1) + xlab(&quot;&quot;) + ylab(&quot;Proportion of variance explained&quot;) +
    labs( title = &quot;The proportion of variance due to individual is larger than \n variance due to C1 batch in ERCC spike-in controls&quot;),
  labels = c(&quot;A&quot;, &quot;B&quot;) )</code></pre>
<pre><code>Warning: Removed 753 rows containing non-finite values (stat_ydensity).</code></pre>
<pre><code>Warning: Removed 753 rows containing non-finite values (stat_boxplot).</code></pre>
<p><img src="figure/paper-additional-analysis.Rmd/unnamed-chunk-17-1.png" title="" alt="" width="1152" style="display: block; margin: auto;" /></p>
<p>Kruskal-wallis test to compare estimated proportion of variance explained.</p>
<pre class="r"><code># Kruskal wallis rank sum test to compare
# proportions of variance explained due to individual
# versus due to replicate

# endogenous raw
kruskal.test(c(prop_list$raw[,1], prop_list$raw[,2]) ~
               rep(c(1,2), each = NROW(blme_raw)) )</code></pre>
<pre><code>
    Kruskal-Wallis rank sum test

data:  c(prop_list$raw[, 1], prop_list$raw[, 2]) by rep(c(1, 2), each = NROW(blme_raw))
Kruskal-Wallis chi-squared = 4888.2, df = 1, p-value &lt; 2.2e-16</code></pre>
<pre class="r"><code># ercc raw
kruskal.test(c(prop_list$ercc[,1], prop_list$ercc[,2]) ~
               rep(c(1,2), each = NROW(prop_list$ercc)) )</code></pre>
<pre><code>
    Kruskal-Wallis rank sum test

data:  c(prop_list$ercc[, 1], prop_list$ercc[, 2]) by rep(c(1, 2), each = NROW(prop_list$ercc))
Kruskal-Wallis chi-squared = 9.6074, df = 1, p-value = 0.001938</code></pre>
<pre class="r"><code># endogenous cpm
kruskal.test(c(prop_list$cpm[,1], prop_list$cpm[,2]) ~
               rep(c(1,2), each = NROW(blme_raw)) )</code></pre>
<pre><code>
    Kruskal-Wallis rank sum test

data:  c(prop_list$cpm[, 1], prop_list$cpm[, 2]) by rep(c(1, 2), each = NROW(blme_raw))
Kruskal-Wallis chi-squared = 2936.4, df = 1, p-value &lt; 2.2e-16</code></pre>
<pre class="r"><code># endogenous cpm transformed (poisson transformed)
kruskal.test(c(prop_list$cpm_trans[,1], prop_list$cpm_trans[,2]) ~
               rep(c(1,2), each = NROW(blme_raw)) )</code></pre>
<pre><code>
    Kruskal-Wallis rank sum test

data:  c(prop_list$cpm_trans[, 1], prop_list$cpm_trans[, 2]) by rep(c(1, 2), each = NROW(blme_raw))
Kruskal-Wallis chi-squared = 5644.3, df = 1, p-value &lt; 2.2e-16</code></pre>
<pre class="r"><code># endogenous final
kruskal.test(c(prop_list$final[,1], prop_list$final[,2]) ~
               rep(c(1,2), each = NROW(blme_raw)) )</code></pre>
<pre><code>
    Kruskal-Wallis rank sum test

data:  c(prop_list$final[, 1], prop_list$final[, 2]) by rep(c(1, 2), each = NROW(blme_raw))
Kruskal-Wallis chi-squared = 10262, df = 1, p-value &lt; 2.2e-16</code></pre>
<p><em>Multivariate distance between C1 preparations</em>: Friedman-Rafsky multivariate run test.</p>
<pre class="r"><code>if (library(&quot;flowMap&quot;, quietly = TRUE, logical.return = TRUE) == FALSE) {
  devtools::install_github(&quot;jhsiao999/flowMap&quot;)
} else {
  library(flowMap)
}</code></pre>
<pre><code>Loading required package: foreach
Loading required package: iterators
Loading required package: parallel</code></pre>
<pre class="r"><code>compute_fr &lt;- function(xx, annotation) {
  batches &lt;- unique(annotation$batch)
  fr_pval &lt;- fr_run &lt;- matrix(0, nrow = length(batches),
                       ncol = length(batches))
  indices &lt;- which(upper.tri(fr_dist, diag = FALSE), arr.ind = TRUE)
  for (i in 1:NROW(indices)) {
    ind_row &lt;- indices[i, 1]
    ind_col &lt;- indices[i, 2]
    fr_res &lt;- 
          getFR(t(as.matrix(xx[,annotation$batch == batches[ind_row]])),
            t(as.matrix(xx[,anno_filter$batch == batches[ind_col]])))
    fr_pval[ind_row, ind_col]  &lt;- fr_res$pNorm
    fr_run[ind_row, ind_col]  &lt;- fr_res$ww
  }
  fr_pval &lt;- Matrix::forceSymmetric(fr_pval)
  diag(fr_pval) &lt;- 1
  return(list(fr_pval = fr_pval,
              fr_run = fr_run))
}</code></pre>
<p>Compute multivariate distance for matrices after each step of transformation.</p>
<pre class="r"><code>fr_raw &lt;- compute_fr(xx = molecules_filter_ENSG,
                     annotation = anno_filter)
fr_cpm &lt;- compute_fr(xx = molecules_cpm,
                     annotation = anno_filter)
fr_cpm_trans &lt;- compute_fr(xx = molecules_cpm_trans,
                     annotation = anno_filter)
fr_final &lt;- compute_fr(xx = molecules_final,
                     annotation = anno_filter)
save(fr_raw, fr_cpm, fr_cpm_trans, fr_final,
     file = &quot;../data/fr-distance.rda&quot;)</code></pre>
<p>Make p-value heatmaps</p>
<pre class="r"><code>load(file = &quot;../data/fr-distance.rda&quot;)
library(gplots)</code></pre>
<pre><code>
Attaching package: &#39;gplots&#39;

The following object is masked from &#39;package:stats&#39;:

    lowess</code></pre>
<pre class="r"><code>heatmap.2(as.matrix(fr_raw$fr_pval), 
          dendrogram = &quot;column&quot;,
          trace = &quot;none&quot;, Rowv = FALSE,
          labRow = unique(anno_filter$batch),
          labCol = unique(anno_filter$batch),
          key = TRUE, main = &quot;Raw&quot;)</code></pre>
<p><img src="figure/paper-additional-analysis.Rmd/unnamed-chunk-20-1.png" title="" alt="" width="768" style="display: block; margin: auto;" /></p>
<pre class="r"><code>heatmap.2(as.matrix(fr_cpm$fr_pval), 
          dendrogram = &quot;column&quot;,
          trace = &quot;none&quot;, Rowv = FALSE,
          labRow = unique(anno_filter$batch),
          labCol = unique(anno_filter$batch),
          key = TRUE, main = &quot;CPM&quot;)</code></pre>
<p><img src="figure/paper-additional-analysis.Rmd/unnamed-chunk-20-2.png" title="" alt="" width="768" style="display: block; margin: auto;" /></p>
<pre class="r"><code>heatmap.2(as.matrix(fr_cpm_trans$fr_pval), 
          dendrogram = &quot;column&quot;,
          trace = &quot;none&quot;, Rowv = FALSE,
          labRow = unique(anno_filter$batch),
          labCol = unique(anno_filter$batch),
          key = TRUE, main = &quot;Poisson&quot;)</code></pre>
<p><img src="figure/paper-additional-analysis.Rmd/unnamed-chunk-20-3.png" title="" alt="" width="768" style="display: block; margin: auto;" /></p>
<pre class="r"><code>heatmap.2(as.matrix(fr_final$fr_pval), 
          dendrogram = &quot;column&quot;,
          trace = &quot;none&quot;, Rowv = FALSE,
          labRow = unique(anno_filter$batch),
          labCol = unique(anno_filter$batch),
          key = TRUE, main = &quot;Final&quot;)</code></pre>
<p><img src="figure/paper-additional-analysis.Rmd/unnamed-chunk-20-4.png" title="" alt="" width="768" style="display: block; margin: auto;" /></p>
</div>
<div id="correlation-between-and-within-batches" class="section level2">
<h2>Correlation between and within batches</h2>
<p>Code for computing correlation between cells within batches and between batches.</p>
<pre class="r"><code>#&#39; molecules_input &lt;- molecules_filter_ENSG
#&#39; annotation &lt;- anno_filter
compute_corr_batch &lt;- function(molecules_input, annotation) {

  cor_mat &lt;- cor(molecules_input, method = &quot;spearman&quot;)
  batch &lt;- unique(annotation$batch)
  individual &lt;- unique(annotation$individual)

  # same individual, within batch
  corr_same_ind_within_batch &lt;-
    lapply(1:length(individual), function(i) {
      batch &lt;-
        unique(annotation$batch[annotation$individual == individual[i]])

      corr_batch &lt;- lapply(1:length(batch), function(i) {
        df &lt;- cor_mat[annotation$batch == batch[i],
                      annotation$batch == batch[i]]
        df[upper.tri(df, diag = FALSE)]
      })
      unlist(corr_batch)
    })

  # same individual, between replicates
  corr_same_ind_between_batch &lt;-
    lapply(1:length(individual), function(i) {
      batch &lt;-
        unique(annotation$batch[annotation$individual == individual[i]])
      submat &lt;- lapply(1:(length(batch)-1), function(i) {
        submat0 &lt;- lapply(2:length(batch), function(j) {
          df &lt;- cor_mat[annotation$batch == batch[i],
                        annotation$batch == batch[j]]
          df[upper.tri(df, diag = FALSE)]
        })
        unlist(submat0)
      })
      unlist(submat)
    })

  # different individual
  corr_diff_ind_between_batch &lt;-
    lapply(1:(length(individual)-1), function(i) {
      if (i == 1) {
        batch &lt;-
          unique(annotation$batch[annotation$individual == individual[i]])
        batch_other &lt;-
          unique(annotation$batch[annotation$individual != individual[i+1]])
      }
      if (i == 2) {
        batch &lt;-
          unique(annotation$batch[annotation$individual == individual[i]])
        batch_other &lt;-
          unique(annotation$batch[annotation$individual == individual[i+1]])
      }

      submat &lt;- lapply(1:length(batch), function(i) {
        submat0 &lt;- lapply(1:length(batch_other), function(j) {
          df &lt;- cor_mat[annotation$batch == batch[i],
                        annotation$batch == batch_other[j]]
          df[upper.tri(df, diag = FALSE)]
        })
        unlist(submat0)
      })
      unlist(submat)
    })
  corr_diff_ind_between_batch &lt;- unlist(corr_diff_ind_between_batch)

  return( list(corr_same_ind_within_batch = corr_same_ind_within_batch,
               corr_same_ind_between_batch = corr_same_ind_between_batch,
               corr_diff_ind_between_batch = corr_diff_ind_between_batch) )

}</code></pre>
<p>Compute correlation for molecule-count data after filtering.</p>
<pre class="r"><code>corr_filter &lt;- compute_corr_batch(molecules_filter_ENSG, anno_filter)
par(mfrow = c(1,1))
boxplot(cbind(corr_filter[[1]][[1]],
              corr_filter[[1]][[2]],
              corr_filter[[1]][[3]],
              corr_filter[[2]][[1]],
              corr_filter[[2]][[2]],
              corr_filter[[2]][[3]],
              corr_filter[[3]]),
        main = &quot;Counts&quot;,
        axes = F)</code></pre>
<pre><code>Warning in cbind(corr_filter[[1]][[1]], corr_filter[[1]][[2]],
corr_filter[[1]][[3]], : number of rows of result is not a multiple of
vector length (arg 1)</code></pre>
<pre class="r"><code>axis(1, at = c(1:7),
     labels = c(&quot;within-batch-19098&quot;,
                      &quot;within-batch-19101&quot;,
                      &quot;within-batch-19239&quot;,
                      &quot;between-batch-19098&quot;,
                      &quot;between-batch-19101&quot;,
                      &quot;between-batch-19239&quot;,
                      &quot;across-batches&quot;))
axis(2)</code></pre>
<p><img src="figure/paper-additional-analysis.Rmd/unnamed-chunk-21-1.png" title="" alt="" width="768" style="display: block; margin: auto;" /></p>
<p>Kruskal wallis comparing all between-batch correlations with all within-batch correlations</p>
<pre class="r"><code>df &lt;- data.frame(corrs = c(unlist(corr_filter[[1]]),
                                unlist(corr_filter[[2]])),
                        label = c(rep(1, length(unlist(corr_filter[[1]]))),
                                  rep(2, length(unlist(corr_filter[[2]]))))) 
kruskal.test(df$corrs ~ df$label)</code></pre>
<pre><code>
    Kruskal-Wallis rank sum test

data:  df$corrs by df$label
Kruskal-Wallis chi-squared = 2210.8, df = 1, p-value &lt; 2.2e-16</code></pre>
<pre class="r"><code># summary statistics of correlations within-batches
# of all three individuals
summary(unlist(corr_filter[[1]]))</code></pre>
<pre><code>   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
 0.6058  0.7222  0.7434  0.7412  0.7618  0.8319 </code></pre>
<pre class="r"><code># summary statistics of correlations between-batches
# of all three individuals
summary(unlist(corr_filter[[2]]))</code></pre>
<pre><code>   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
 0.6113  0.7080  0.7294  0.7263  0.7475  0.8282 </code></pre>
</div>
<div id="session-information" class="section level2">
<h2>Session information</h2>
<pre class="r"><code>sessionInfo()</code></pre>
<pre><code>R version 3.2.0 (2015-04-16)
Platform: x86_64-unknown-linux-gnu (64-bit)

locale:
 [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
 [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
 [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   
 [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
 [9] LC_ADDRESS=C               LC_TELEPHONE=C            
[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       

attached base packages:
[1] parallel  stats     graphics  grDevices utils     datasets  methods  
[8] base     

other attached packages:
 [1] gplots_2.17.0     flowMap_1.7.0     scales_0.4.0     
 [4] reshape2_1.4.1    abind_1.4-3       doParallel_1.0.10
 [7] iterators_1.0.8   foreach_1.4.3     ade4_1.7-4       
[10] lme4_1.1-10       Matrix_1.2-1      lmtest_0.9-34    
[13] zoo_1.7-12        cowplot_0.3.1     ggplot2_1.0.1    
[16] dplyr_0.4.2       knitr_1.10.5     

loaded via a namespace (and not attached):
 [1] Rcpp_0.12.4        formatR_1.2        nloptr_1.0.4      
 [4] plyr_1.8.3         bitops_1.0-6       tools_3.2.0       
 [7] digest_0.6.8       evaluate_0.7       gtable_0.1.2      
[10] nlme_3.1-120       lattice_0.20-31    DBI_0.3.1         
[13] yaml_2.1.13        proto_0.3-10       httr_0.6.1        
[16] stringr_1.0.0      caTools_1.17.1     gtools_3.5.0      
[19] grid_3.2.0         R6_2.1.1           rmarkdown_0.6.1   
[22] gdata_2.16.1       minqa_1.2.4        magrittr_1.5      
[25] codetools_0.2-11   htmltools_0.2.6    MASS_7.3-40       
[28] splines_3.2.0      assertthat_0.1     colorspace_1.2-6  
[31] labeling_0.3       KernSmooth_2.23-14 stringi_1.0-1     
[34] RCurl_1.95-4.6     lazyeval_0.1.10    munsell_0.4.3     </code></pre>
</div>


<!-- some extra javascript for older browsers -->
<script type="text/javascript" src="libs/polyfill.js"></script>

<script>

// manage active state of menu based on current page
$(document).ready(function () {

    // active menu
    href = window.location.pathname
    href = href.substr(href.lastIndexOf('/') + 1)
    $('a[href="' + href + '"]').parent().addClass('active');

    // manage active menu header
    if (href.startsWith('authoring_'))
      $('a[href="' + 'authoring' + '"]').parent().addClass('active');
    else if (href.endsWith('_format.html'))
      $('a[href="' + 'formats' + '"]').parent().addClass('active');
    else if (href.startsWith('developer_'))
      $('a[href="' + 'developer' + '"]').parent().addClass('active');

});

</script>

</div>

<script>

// add bootstrap table styles to pandoc tables
$(document).ready(function () {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
});

</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
