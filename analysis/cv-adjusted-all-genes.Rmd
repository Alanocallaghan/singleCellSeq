---
title: "Compare Coefficient of variation between individuals"
author: "Joyce Hsiao"
date: 2015-10-14
---

**Last updated:** `r Sys.Date()`

**Code version:** `r system("git log -1 --format='%H'", intern = TRUE)`

```{r chunk-options, include=FALSE}
source("chunk-options.R")

library(knitr)
opts_chunk$set(message = FALSE, warning = FALSE, eval = TRUE, 
               echo = TRUE)
```


## Objective

We normalize CVs ([link]) and use a per gene linear model to compare normalized coefficient of variations across individuals. The voom plot of normalized coefficients of variation indicate that normliazed CV qualifies the assumption of homogeneity of variances in linear model. 

[link]: http://jdblischak.github.io/singleCellSeq/analysis/cv-adjusted.html

The analyses in this document include both endogeneous genes and ERCC genes. However, results suggest that we should interpret these results with a grain of salt, noting that most of the top significant genes are ERCC genes.


## Set up

```{r, message=FALSE, warning=FALSE}
library("data.table")
library("dplyr")
library("limma")
library("edgeR")
library("ggplot2")
library("grid")
library("zoo")
theme_set(theme_bw(base_size = 12))
source("functions.R")
```



## Prepare data

Input annotation of only QC-filtered single cells

```{r}
anno_qc <- read.table("../data/annotation-filter.txt", header = TRUE,
                   stringsAsFactors = FALSE)
head(anno_qc)
```


Input endogeneous gene molecule counts that are QC-filtered, CPM-normalized, ERCC-normalized, and also processed to remove unwanted variation from batch effet. ERCC genes are removed from this file.

```{r}
molecules_ENSG <- read.table("../data/molecules-final.txt", header = TRUE, stringsAsFactors = FALSE)
```

Input ERCC gene moleclue counts that are QC-filtered and CPM-normalized. 

```{r}
molecules_ERCC <- read.table("../data/molecules-cpm-ercc.txt", header = TRUE, stringsAsFactors = FALSE)
```

Combine endogeneous and ERCC genes.

```{r}
molecules_all_genes <- rbind(molecules_ENSG, molecules_ERCC)
```


Input endogeneous and ERCC gene moleclule counts before log2 CPM transformation. This file is used to compute percent zero-count cells per sample.

```{r}
molecules_filter <- read.table("../data/molecules-filter.txt", header = TRUE, stringsAsFactors = FALSE)

stopifnot( all.equal(rownames(molecules_all_genes), rownames(molecules_filter)) )
```



## Normalize coefficient of variation

Compute coefficient of variation.

```{r}
# Compute CV and mean of normalized molecule counts (take 2^(log2-normalized count))

molecules_cv_batch <- 
  lapply(1:length(unique(anno_qc$batch)), function(per_batch) {
      molecules_per_batch <- 2^molecules_all_genes[ , unique(anno_qc$batch) == unique(anno_qc$batch)[per_batch] ]
      mean_per_gene <- apply(molecules_per_batch, 1, mean, na.rm = TRUE)
      sd_per_gene <- apply(molecules_per_batch, 1, sd, na.rm = TRUE)
      cv_per_gene <- data.frame(mean = mean_per_gene,
                                sd = sd_per_gene,
                                cv = sd_per_gene/mean_per_gene)
      rownames(cv_per_gene) <- rownames(molecules_all_genes)
  
      # cv_per_gene <- cv_per_gene[rowSums(is.na(cv_per_gene)) == 0, ]
      cv_per_gene$batch <- unique(anno_qc$batch)[per_batch]
      
      # Add sparsity percent
      molecules_count <- molecules_filter[ , unique(anno_qc$batch) == unique(anno_qc$batch)[per_batch]]
      cv_per_gene$sparse <- rowMeans(as.matrix(molecules_count) == 0)
        
      return(cv_per_gene)
      }) 
names(molecules_cv_batch) <- unique(anno_qc$batch)

sapply(molecules_cv_batch, dim)
```


Merge summary data.frames.

```{r}
df_plot <- do.call(rbind, molecules_cv_batch)
```

Compute rolling medians across all samples.

```{r}
# Compute a data-wide coefficient of variation on CPM normalized counts.
data_cv <- apply(2^molecules_all_genes, 1, sd)/apply(2^molecules_all_genes, 1, mean)

# Order of genes by mean expression levels
order_gene <- order(apply(2^molecules_all_genes, 1, mean))

# Rolling medians of log10 squared CV by mean expression levels
roll_medians <- rollapply(log10(data_cv^2)[order_gene], width = 50, by = 25,
                         FUN = median, fill = list("extend", "extend", "NA") )
ii_na <- which( is.na(roll_medians) )
roll_medians[ii_na] <- median( log10(data_cv^2)[order_gene][ii_na] )

names(roll_medians) <- rownames(molecules_all_genes)[order_gene]

# re-order rolling medians
reorder_gene <- match(rownames(molecules_all_genes), names(roll_medians) )
head(reorder_gene)
roll_medians <- roll_medians[ reorder_gene ]

stopifnot( all.equal(names(roll_medians), rownames(molecules_all_genes) ) )
```


Compute adjusted coefficient of variation.

```{r}
# adjusted coefficient of variation on log10 scale
log10cv2_adj <- 
  lapply(1:length(molecules_cv_batch), function(per_batch) {
    foo <- log10(molecules_cv_batch[[per_batch]]$cv^2) - roll_medians
    return(foo)
})
df_plot$log10cv2_adj <- do.call(c, log10cv2_adj)
df_plot$is_ERCC <- ( 1:dim(df_plot)[1] %in% grep("ERCC", rownames(df_plot)) )
```



## limma

We use the *lmFit* function in the limma package to fit linear models comparing coefficients of variations between individuals for all genes. *lmFit* provides a fast algorithm for least-square estimation, when design matrix is the same for all genes.

```{r}
library(limma)

df_limma <- matrix(df_plot$log10cv2_adj, 
                      nrow = nrow(molecules_all_genes), ncol = 9, byrow = FALSE)

design <- data.frame(individual = factor(rep(unique(anno_qc$individual), each = 3) ),
                     rep = factor(rep(c(1:3), times = 3)) )

colnames(df_limma) <- with(design, paste0(individual, rep))

fit_limma <- lmFit(df_limma, design = model.matrix( ~ individual, data = design))                      
fit_limma <- eBayes(fit_limma)
```

Voom plot of all genes

```{r}
voom(10^df_limma, design = model.matrix(~individual, data = design),
     plot = TRUE)
```


Voom plot of only endogeneous genes

```{r}
is_ERCC <- c(1:dim(df_limma)[1]) %in% grep("ERCC", rownames(molecules_all_genes))
voom(10^df_limma[which(!is_ERCC), ], design = model.matrix(~individual, data = design),
     plot = TRUE)
```


limma unmoderated F-test p-value

```{r}
hist(fit_limma$F.p.value, breaks = 100, main = "F-test p-value")
```


False discover control adjutment.

```{r}
F.p.adj <- p.adjust(fit_limma$F.p.value, method = "fdr")
summary(F.p.adj)

hist(F.p.adj, main = "False discovery rate", xlab = "FDR")
```

Cutoffs

```{r}
df_cuts <- data.frame(cuts = c(.001, .01, .05, .1, .15, .2))
df_cuts$sig_count <- sapply(1:6, function(per_cut) {
                    sum(F.p.adj < df_cuts$cuts[per_cut] )
                    })
df_cuts
```

P-value before versus after false discovery adjustment.

```{r}
plot(y = F.p.adj, x = fit_limma$F.p.value,
     xlab = "F-test p-value", ylab = "FDR")
```


## P-value and sparsity

```{r}
df_sparse <- rowMeans(matrix(df_plot$sparse, nrow = nrow(molecules_all_genes), ncol = 9,
                      byrow = FALSE) )

is_ERCC <- (1:dim(df_plot)[1] %in% grep("ERCC", rownames(df_plot)) )
plot(x = df_sparse, y = log10(fit_limma$F.p.value),
     xlab = "Average percent of zero-count cells",
     ylab = "log10(p-value of F-test)",
     main = "CV and sparsity of all genes", col = "grey60")
points(x = df_sparse[is_ERCC], y = log10(fit_limma$F.p.value)[is_ERCC],
       col = "red", pch = 16, cex = .8)


plot(x = df_sparse[!is_ERCC], y = log10(fit_limma$F.p.value)[!is_ERCC],
     xlab = "Average percent of zero-count cells",
     ylab = "log10(p-value of F-test)",
     main = "CV and sparsity of ENSG genes", col = "grey60")
```

Correlation between mean sparsity rate and p-value.

```{r}
cor(df_sparse, fit_limma$F.p.value, method = "spearman")
```


## CPM density distributions of significant genes

Rank genes by FDR.

```{r}
order_limma <- order(F.p.adj)

ggplot(data.frame(values = unlist(molecules_all_genes[order_limma[1],] ),
                  individual = factor(anno_qc$individual),
                  replicate = factor(anno_qc$replicate),
                  batch = factor(anno_qc$batch), check.rows = F), aes(x = values)) + 
  geom_density(aes(group = batch, col = individual)) +
  ggtitle(paste("The most significant gene", rownames(molecules_all_genes)[order_limma[1]]) )

ggplot(data.frame(values = unlist(molecules_all_genes[order_limma[2],] ),
                  individual = factor(anno_qc$individual),
                  replicate = factor(anno_qc$replicate),
                  batch = factor(anno_qc$batch), check.rows = F), aes(x = values)) + 
  geom_density(aes(group = batch, col = individual)) +
  ggtitle(paste("The second significant gene", rownames(molecules_all_genes)[order_limma[2]]) )

ggplot(data.frame(values = unlist(molecules_all_genes[order_limma[3],] ),
                  individual = factor(anno_qc$individual),
                  replicate = factor(anno_qc$replicate),
                  batch = factor(anno_qc$batch), check.rows = F), aes(x = values)) + 
  geom_density(aes(group = batch, col = individual)) +
  ggtitle(paste("The third significant gene", rownames(molecules_all_genes)[order_limma[3]]) )
```


## ERCC ranks in FDR

Most are ranked as very high in individual differences and some are very low. A quick glance of the density distributions of molecule counts across cells suggest that this may be the result of high molecule counts in NA19098 batch 2.

```{r}
ordered_genes_FDR <- rownames(molecules_all_genes)[order(F.p.adj)]

grep("ERCC", ordered_genes_FDR)
```





## Session information

```{r info}
sessionInfo()
```
