---
title: "Effect of merging UMIs within edit distance of 1"
date: 2016-01-07
---

**Last updated:** `r Sys.Date()`

**Code version:** `r system("git log -1 --format='%H'", intern = TRUE)`

```{r chunk-options, include=FALSE}
source("chunk-options.R")
opts_chunk$set(fig.width = 8, fig.height = 8)
```

```{r packages, message=FALSE}
library("data.table")
library("dplyr")
library("limma")
library("edgeR")
library("ggplot2")
library("grid")
library("cowplot")
theme_set(theme_bw(base_size = 12))
source("functions.R")
```

To avoid overcounting molecules due to PCR and/or sequencing errors in the UMIs, we merged all UMIs within an edit distance of 1.
Below we show that this systematically reduces the number of molecules per genes (as expected), but does not qualitatively change the relationship between single cells of different individuals.

## Process the non-merged UMI data as before

We start with the gene counts file produced by our [pipeline for processing the sequencing data](process-samples.html).

```{r input, cache = TRUE}
counts <- fread("/mnt/gluster/data/internal_supp/singleCellSeq/gene-counts.txt")
```

It is a very large file, and when read into R it uses `r format(object.size(counts), units = "GB")` of memory.
Each row corresponds to a specific sample processed in a specific manner.

```{r inspect}
counts %>% select(1:10) %>% slice(1:10)
```

This granular data is used for performing [quality control at the level of sequencing lane](qc-by-lane.html).

### Sum counts per lane by sample

For downstream analyses, we need to sum the number of reads or molecules for every gene for each sample across sequencing runs.
The molecule counts derived using this method will be inflated because duplicate reads (i.e. have the same UMI and start site) will only be removed within a lane.
Thus these per-lane molecule count levels are only used for QC purposes.

```{r summarise}
counts_by_sample <- counts %>%
  filter(!is.na(lane), sickle == "quality-trimmed") %>%
  select(individual, batch, well, rmdup, starts_with("ENSG"), starts_with("ERCC")) %>%
  group_by(individual, batch, well, rmdup) %>%
  summarise_each(funs(sum)) %>%
  arrange(individual, batch, well, rmdup) %>%
  ungroup
```

### Create annotation file

The annotation file contains the meta-information for each sample.

```{r annotation}
anno <- counts_by_sample %>%
  filter(rmdup == "molecules") %>%
  select(individual:well) %>%
  as.data.frame
```

Reformat the annotation file:

*  Add the string "NA" in front of the individual ID's so that they are not interpreted as numeric
*  The column denoting the 3 replicates is now named `replicate`
*  Add the string "r" in front of the replciate numbers so that they are not interpreted as numeric
*  Create new column called `batch` which corresponds to the 9 batches (3 individuals x 3 reps)

```{r reformat-annotation}
anno <- anno %>% rename(replicate = batch) %>%
  mutate(individual = paste0("NA", individual),
         replicate = paste0("r", replicate),
         batch = paste(individual, replicate, sep = "."),
         sample_id = paste(batch, well, sep = "."))
head(anno)
```

### Create reads file

The reads file contains only the counts.
Each row is a gene and each column is a sample.
The columns in the reads file correspond to the rows in the annotation file.

```{r transpose-reads}
reads <- counts_by_sample %>%
  filter(rmdup == "reads") %>%
  select(-(individual:rmdup)) %>%
  t
dim(reads)
colnames(reads) <- anno$sample_id
reads[1:10, 1:5]
```

Only genes with at least one read observed in at least one of the single cell or bulk samples are maintained.

```{r genes-observed}
genes_observed <- rownames(reads)[rowSums(reads) > 0]
reads <- reads[rownames(reads) %in% genes_observed, ]
```

There are `r length(genes_observed)` genes with at least one read.

Separate the bulk samples from the single cells.

```{r separate-bulk-reads}
reads_bulk <- reads[, anno$well == "bulk"]
reads <- reads[, anno$well != "bulk"]
stopifnot(ncol(reads_bulk) == 3 * 3, ncol(reads) == 3 * 3 * 96)
```

### Create molecules file

Reads with the same UMI and start position need to be removed using all the data for a given sample.
Otherwise the counts will be inflated because the same read can be sequenced across multiple lanes.
Post-mapping we combined all the reads per sample and removed duplicate UMIs ([pipeline][]).
The data from these combined samples have `NA` recorded for index, lane, and flow_cell.

[pipeline]: process-samples.html#process-at-the-sample-level

```{r select-sort-combined-counts}
counts_combined <- counts %>%
  filter(is.na(lane), sickle == "quality-trimmed") %>%
  select(individual, batch, well, rmdup, starts_with("ENSG"), starts_with("ERCC")) %>%
  arrange(individual, batch, well, rmdup)
stopifnot(counts_combined$individual[c(TRUE, FALSE)] == substr(anno$individual, 3, 8),
          counts_combined$batch[c(TRUE, FALSE)] == substr(anno$replicate, 2, 2),
          counts_combined$well[c(TRUE, FALSE)] == anno$well)
```

Create molecules file similar to reads file.

```{r transpose-molecules}
molecules <- counts_combined %>%
  filter(rmdup == "molecules") %>%
  select(-(individual:rmdup)) %>%
  t
dim(molecules)
colnames(molecules) <- anno$sample_id
```

Only genes with at least one read observed in at least one of the single cell or bulk samples are maintained.

```{r filter-genes-observed-molecules}
molecules <- molecules[rownames(molecules) %in% genes_observed, ]
stopifnot(nrow(molecules) == nrow(reads))
```

Remove bulk samples from molecules file.
Because bulk samples have many more molecules than a single cell, the UMIs are not valid.

```{r remove-bulk-molecules}
molecules <- molecules[, anno$well != "bulk"]
stopifnot(ncol(molecules) == 3 * 3 * 96)
```

## Process merged UMI data

The data file contains only the molecule counts for the single cells.

```{r}
molecules_new_raw <- fread("/mnt/gluster/home/jdblischak/ssd/molecules-raw-single-per-sample.txt")
setDF(molecules_new_raw)
stopifnot(anno$individual[anno$well != "bulk"] == molecules_new_raw$individual,
          anno$replicate[anno$well != "bulk"] == molecules_new_raw$replicate,
          anno$well[anno$well != "bulk"] == molecules_new_raw$well)
```

Transpose the matrix.

```{r}
molecules_new <- molecules_new_raw %>%
  select(-(individual:well)) %>%
  t
colnames(molecules_new) <- anno$sample_id[anno$well != "bulk"]
```

Remove unexpressed genes as above.

```{r}
molecules_new <- molecules_new[rownames(molecules_new) %in% genes_observed, ]
stopifnot(rownames(molecules) == rownames(molecules_new))
```

## Total molecule counts

Compare the total molecule counts for each single cell.
Blue is the x=y line; red is the best fit line.

```{r}
molecules_total <- colSums(molecules)
molecules_new_total <- colSums(molecules_new)
lm_total <- lm(molecules_new_total ~ molecules_total)
summary(lm_total)
plot(molecules_total, molecules_new_total,
     xlab = "Total number of molecules per cell (no merging)",
     ylab = "Total number of molecules per cell (merged)",
     main = "Reduction in total molecule count after merging UMIs",
     sub = sprintf("blue: x = y;  red: y = %.2fx + %.2f",
                   lm_total$coefficients[2], lm_total$coefficients[1]))
abline(0, 1, col = "blue")
abline(lm_total, col = "red")
```

## PCA

Identify the 2500 most variable genes.

```{r}
gene_variability <- apply(molecules, 1, var)
most_variable <- rownames(molecules)[order(gene_variability, decreasing = TRUE)][1:2500]
```

```{r}
molecules_pca <- run_pca(cpm(molecules[most_variable, ]))
plot_pca(molecules_pca$PCs, explained = molecules_pca$explained,
         metadata = anno[anno$well != "bulk", ], color = "individual",
         shape = "replicate") +
  labs(title = "PCA on non-merged molecules")
```

```{r}
molecules_new_pca <- run_pca(cpm(molecules_new[most_variable, ]))
plot_pca(molecules_new_pca$PCs, explained = molecules_new_pca$explained,
         metadata = anno[anno$well != "bulk", ], color = "individual",
         shape = "replicate") +
  labs(title = "PCA on merged molecules")
```

The results are qualitatively similar.

## PCA- ERCC

```{r}
molecules_ercc <- molecules[grepl("ERCC", rownames(molecules)), ]
molecules_ercc_pca <- run_pca(cpm(molecules_ercc, log = TRUE))
plot_pca(molecules_ercc_pca$PCs, explained = molecules_ercc_pca$explained,
         metadata = anno[anno$well != "bulk", ], color = "individual",
         shape = "replicate") +
  labs(title = "PCA on non-merged ERCC molecules")
```

```{r}
molecules_new_ercc <- molecules_new[grepl("ERCC", rownames(molecules_new)), ]
molecules_new_ercc_pca <- run_pca(cpm(molecules_new_ercc, log = TRUE))
plot_pca(molecules_new_ercc_pca$PCs, explained = molecules_new_ercc_pca$explained,
         metadata = anno[anno$well != "bulk", ], color = "individual",
         shape = "replicate") +
  labs(title = "PCA on merged ERCC molecules")
```

The inversion of the axis is arbitrary.
The results are qualitatively similar.

## Looking at individual single cells

A similar reduction is observed for a given individual.

```{r}
lm_ind_1 <- lm(molecules_new[, 1] ~ molecules[, 1])
summary(lm_ind_1)
plot(molecules[, 1], molecules_new[, 1],
     col = ifelse(grepl("ERCC", rownames(molecules)), "green", "black"),
     xlab = "Molecules per gene (no merging)",
     ylab = "Molecules per gene (merged)",
     main = "Reduction in molecules per gene after merging UMIs (NA19098.r1.A01)",
     sub = sprintf("blue: x = y;  red: y = %.2fx + %.2f",
                   lm_ind_1$coefficients[2], lm_ind_1$coefficients[1]))
abline(0, 1, col = "blue")
abline(lm_ind_1, col = "red")
```

Is the reduction similar across cells?

```{r}
intercepts <- numeric(length = ncol(molecules))
slopes <- numeric(length = ncol(molecules))
r2 <- numeric(length = ncol(molecules))
for (i in 1:ncol(molecules)) {
  lm_ind <- lm(molecules_new[, i] ~ molecules[, i])
  intercepts[i] <- lm_ind$coefficients[1]
  slopes[i] <- lm_ind$coefficients[2]
  r2[i] <- summary(lm_ind)$r.squared
}
```

```{r}
boxplot(intercepts ~ anno$replicate[anno$well != "bulk"] +
          anno$individual[anno$well != "bulk"], las = 2, cex.axis = 0.9,
        ylab = "Intecept")
boxplot(slopes ~ anno$replicate[anno$well != "bulk"] +
           anno$individual[anno$well != "bulk"], las = 2, cex.axis = 0.9,
        ylab = "Slope")
boxplot(r2 ~ anno$replicate[anno$well != "bulk"] +
           anno$individual[anno$well != "bulk"], las = 2, cex.axis = 0.9,
        ylab = "R squared")
```

Overall the differences in the reduction between single cell batches are minimal in magnitude.

## Session information

```{r info}
sessionInfo()
```
